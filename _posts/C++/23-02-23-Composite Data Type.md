---
layout: single
title: "Composite Data Type"
categories: TIL
---
# 복합 데이터형
일상에서 코딩을 하다보면 앞서 배운 기본 데이터형만 가지고는 이러한 데이터를 처리할 수가 없다. 그렇기 때문에 C++는 복합 데이터형을 제공한다. 복합 데이터형은 기본 정수형과 부동 소수점형으로부터 만들어진다. 이들 복합 데이터형 중에서 가장 복잡한 것은 클래스이다.  
C++는 C로부터 가져온 몇 가지 다른 복합형들도 제공한다. 예를 들어, 배열(array)은 동일한 데이터형의 값 여러 개를 연속적으로 저장할 수 있다. 어떤 특정한 종류의 배열은 무자열 즉, 연속된 문자들을 저장할 수 있다. 구조체(structure)는 종류가 다른 여러 데이터형의 값을 함께 저장할 수 있다. 또한 포인터(pointer)라는 것이 있다. 포인터는 데이터가 저장되어 있는 주소를 컴퓨터에게 알려 주는 변수이다. 이번 단원에서는 클래스를 제외한 모든 복합형들에 대해 알아본다. 또한 new와 delete를 처음으로 살펴보고, 그들을 사용하여 데이터를 다루는 법을 알아본다. 그리고 문자열을 다루는 또 다른 방법인 C++의 string클래스르 간단하게 알아본다.
<hr> <br>

# 1. 배열
배열(array)은 데이터형이 같은 여러 개의 값을 연속적으로 저장할 수 있는 데이터 구조이다.  
배열은 선언 구문을 사용하여 생성한다. 배열 선언 구문에서는 다음과 같은 세 가지를 선언한다.
<ul type = square>
<li> 각 원소에 저장될 값의 데이터형</li>
<li> 배열의 이름</li>
<li> 배열 원소의 개수</li>
</ul>

C++에서는 간단한 변수의 선언 형식을 수정하여 배열을 선언한다. 즉, 배열 원소의 개수를 대괄호 안에 넣어 선언한다.
```
short months(12);       // 12개의 short형 값을 넣을 수 있는 배열을 생성
```
위의 코드는 배열의 이름이 months이고, 12개의 원소를 가지며, 각 원소에는 short형 값을 저장할 수 있다는 것을 나타낸다. 배열의 각 원소는 개별적으로 간단한 변수처럼 취급할 수 있는 변수이다.  
  
다음은 배열을 선언하는 일반적인 형식이다.
```cpp
typeName arrayName(arraySize);
```
원소의 개수를 나타내는 arraysize는 값 10 또는 const 기호 상수와 같은 정수 상수이거나, 또는 컴파일할 때 값이 결정되는 8 * sizeof(int)와 같은 상수 수식이어야 한다. 특히 프로그램이 실행되는 동안에 값이 결정되는 변수는 arraySize가 될 수 없다. 그러나 new 연산자를 사용하여 이러한 제약을 피하는 방법도 있다.  
  
배열이 여러 가지 용도로 유용한 것은 각각의 배열 원소에 개별적으로 접근할 수 있기 때문이다. 개별적인 접근을 허용하기 위해 인덱스(subscript) 또는 인덱스(index)를 사용하여 배열 원소에 차례로 번호가 매겨진다. C++의 배열 인덱스는 항상 0부터 시작한다. 그리고 C++는 대괄호 안에 인덱스를 넣어 배열 원소를 지정한다.  
  
Listing 4.1은 배열을 선언하고, 배열 원소에 값을 대입하며, 배열을 초기화하는 것과 같은 배열에 관련된 몇 가지 사항을 보여준다.
```cpp
// Listing 4.1
// arrayone.cpp

#include <iostream>
int main()
{
    using namespace std;
    int yams[3];                // 3개의 원소를 가진 배열을 선언
    yams[0] = 7;                // 첫 번째 원소에 값을 대입
    yams[1] = 8;
    yams[2] = 6;

    int yamcosts[3] = {200, 300, 50};   // 배열을 생성하고 초기화
    // 참고: 사용하는 C++ 컴파일러나 번역기가 이 배열을 초기화할 수 없다면
    // int yamcosts[3] 대신에 static int yamcosts[3]을 사용하라

    cout << "고구마 합계 = ";
    cout << yams[0] + yams[1] + yams[2] << endl;
    cout << yams[1] << "개가 들어 있는 포장은 ";
    cout << "개당 " << yamcosts[1] << "원씩입니다.\n";
    int total = yams[0] * yamcosts[0] + yams[1] * yamcosts[1];
    total = total + yams[2] * yamcosts[2];
    cout << "세 포장의 총 가격은 " << total << "원입니다.\n";
    cout << "\nyams 배열의 크기는 " << sizeof yams;
    cout << "바이트입니다.\n";
    cout << "원소 하나의 크기는 " << sizeof yams[0];
    cout << "바이트입니다.\n";
    return 0;
}
```

### 프로그램 분석
Listing 4.1 프로그램은 3개의 원소를 가진 yams라는 배열을 생성한다. yams는 원소가 3개인 배열이므로 배열 원소들의 인덱스는 0, 1, 2가 된다.  
위 코드는 yams배열의 세 원소에 고지식한 방법으로 값을 대입하고 있다. 그러나 이렇게 하지 않고 선언 구문에서 배열 원소를 직접 초기화할 수도 있다. Listing 4.1은 yamcosts 배열에 이 방법으로 값을 대입하고 있다.
```cpp
int yamcosts[3] = {200, 300 ,50};
```
이 방법은 배열 원소에 대입할 값들을 콤마로 구분하여 중괄호로 묶은 초기화 리스트를 간단하게 제공한다. 중괄호 안의 리스트에 빈칸이 있어도 되고 없어도 된다. 함수 안에서 정의된 배열을 초기화 하지 않으면, 배열 원소의 값들은 미확정 상태로 남는다. 즉, 배열 원소들은 그 메모리 위치에 전부터 우연히 남아있던 쓰레기 값들로 취한다.  

그리고 배열 원소들의 산술연산을 진행하였는데 인덱스와 대괄호의 사용 때문에 무척 고지식해 보인다. 하지만 아직 for문이나 while문에 대해 공부하지 않았으므로 이번 단원에서는 위와 같이 작성하였다.  
  
기억을 되살리면 sizeof 연산자는 데이터형이나 데이터 객체의 크기를 바이트 단위로 리턴한다. 배열 이름에 sizeof 연산자를 적용하면 그 배열의 전체 크기가 바이트 단위로 리턴된다. 그러나 배열 원소에 sizeof 연산자를 적용하면 배열 원소의 크기를 바이트 단위로 리턴한다.<br><br>
  
## 배열 초기화 규칙

C++는 배열을 초기화하는 데 몇 가지 규칙을 적용하고 있다. 이 규칙은 배열 초기화를 할 수 있는 시기를 제한한다. 또한 배열 원소의 개수와 초기화 리스트에 제시된 값의 개수가 일치하지 않을 때 어떻게 할 것인지를 결정한다.
초기화 형식은 배열을 정의하는 곳에서만 사용할 수 있다. 초기화를 나중에 할 수는 없다. 배열을 다른 배열에 통째로 대입할 수도 없다.
```cpp
int cards[4] = {3, 6, 8, 10}        // 맞다.
int hand[4];                        // 맞다.
hand[4] = {5, 6, 7, 8}              // 틀리다.
hand = cards;                       // 틀리다.
```
그러나 인덱스를 사용하여 배열 원소에 개별적으로 값을 대입하는 것은 언제든지 가능하다. 배열을 초기화할 때, 초기화 값의 개수를 배열 원소의 개수보다 모자라게 제공할 수도 있다.
```cpp
float arr[5] = {5.0, 2.5};
```
배열을 부분적으로 초기화하면 컴파일러는 나머지 원소들을 자동으로 0으로 설정한다. 따라서 zeros와 같은 원소가 모두 0인 행렬은 배열의 첫 번째 원소만 0으로 초기화 시키면 간단하게 만들 수 있다.
```cpp
long zeros[500] = {0};
```
배열을 초기화할 때 대괄호 속을 비워두면, 컴파일러가 초기화 값의 수를 헤아려 배열 원소의 개수를 결정한다.
```cpp
short things[] = {1, 2, 3, 4};
```
배열 원소의 수가 4개인 short형의 배열 things를 생성한다.
<hr><br>

# 2. 문자열
문자열(string)이란 메모리에 바이트 단위로 연속적으로 저장되어 있는 문자들을 말한다. C++는 두 가지 방법으로 문자열을 처리한다. 첫 번째는 C로부터 유래한 C 스타일의 문자열 처리 방법으로, 이 단원에서는 이 방법을 먼저 알아본다. 또 다른 방법은 단원의 뒤에서 알아본다.  
  
문자들이 메모리에 바이트 단위로 저장된다는 것은, 문자열을 char형의 배열에 저장할 수 있다는 것을 의미한다. 이때 문자열을 구성하는 각 문자들은 배열의 원소에 하나씩 저장된다.  
C 스타일의 문자열은 특별한 특징을 가지고 있다. 모든 문자열의 마지막 문자가 반드시 널 문자(null character)여야 한다는 것인데 널 문자는 \0로 쓰며, ASCII 코드가 0인 문자이다. 그것은 문자열의 끝을 표시한다. 다음 두 구문을 비교해보자.
```cpp
char dog[8] = {'b', 'e' , 'a', 'u', 'x', ' ', 'I', 'I'};    // 문자열이 아니다.
char cat[8] = {'f', 'a', 't', 'e', 's', 's', 'a', '\0'};    // 문자열이다.
```
두 배열이 모두 char형의 배열이다. 그러나 두 번째 배열만이 문자열이다. 널 문자는 C스타일의 문자열에서 중요한 역할을 한다. 예를 들어 C++는 cout이 사용하는 함수들도 포함하여, 많은 문자열 처리 함수를 가지고 있다. 이 함수들은 널 문자를 만날 때까지 문자 단위로 문자열을 처리한다. 앞에 예로 든 cat문자열을 cout으로 출력하면, 8개의 문자를 출력하고 나서 널 문자를 만나면 출력을 중단한다.<br><br>

그러나 앞의 예에서 문자열이 아닌 dog를 cout으로 출력하면, 배열에 들어 있는 5개의 문자를 모두 출력한 뒤에도 그 이후의 메모리 내용을 한 바이트씩 문자로 간주하여 계속해서 출력한다. 출력은 우연히 널 문자를 만날 때까지 이어진다. 그러나 값이 0으로 설정되는 널 문자들은 메모리에 아주 흔하기 때문에, 출력이 그렇게 오래 지속되지는 않는다.<br><br>

앞의 예에서 문자열을 하나하나 작은 따옴표로 묶어 콤마로 구분하는 일은 매우 귀찮은 일이었다. 이보다 좋은 방법은 char형의 배열을 문자열로 초기화하는 것이다.
```cpp
char bird[11] = "Mr.Cheeps"     // \0을 저장한다.
char fish[] = "Bubbles"         // 컴파일러가 알아서 처리한다.
```
위와 같이 큰 따옴표로 묶인 문자열을 문자열 상수(string constant 또는 string literal)이라 한다. 큰 따옴표로 묶인 문자열은 끝내기 널 문자를 암시적으로 갖고 있다. 그러미로 문자열의 끝에 널 문자를 명시적으로 넣을 필요가 없다.

```cpp
char shirt_size = 'S';
char shirt_size = "S";
```
위 두 코드를 보자. 첫 코드의 'S'는 문자 상수 83을 의미하며 프로그램에서 실행하게 되면 문제가 발생하지 않는다. 두 번째 코드의 "S"는 내부적으로 문자열이 저장되어 있는 메모리 주소를 나타내며 코드는 char형 변수에 메모리 주소를 대입하는 코드이다. 메모리 주소와 char형은 다른 종류의 데이터형이기 때문에 에러가 발생한다. 이에 대해서는 뒤에 포인터를 다룰 때 더 알아보도록 하자.<br><br>

## 문자열 상수의 결합
어떤 문자열은 너무 길어서 한 행으로 표현할 수 없다. 이러한 경우에 C++에서는 문자열 상수들을 결합할 수 있다. 즉, 큰 따옴표로 묶인 두 문자열을 하나로 결합할 수 있다. 빈칸, 탭, 캐리지 리턴과 같은 화이트 스페이스(white space)로 분리된 두 개의 문자열 상수는 하나의 문자열 상수로 결합된다.
```cpp
cout << "I'd give my right arm to be a great violinist.\n";
cout << "I'd give my right arm to be" "a great violinist.\n";
cout << "I'd give my right ar" "m to be a great violinist.\n"
```
위 세 개의 출력 구문은 모두 동일하다. 이때 결합된 문자열에는 어떠한 빈칸도 추가되지 않는다. \0을 뺀 첫 번째 문자열의 마지막 문자에 두 번째 문자열의 첫 문자가 이어진다. 즉, 첫 번째 문자열의 \0가 두 번째 문자열의 첫 문자로 대체된다.<br><br>

## 배열에 문자열 사용
배열에 문자열을 넣는 가장 일반적인 방법은 두 가지이다. 배열을 문자열 상수로 초기화하는 방법과, 키보드 입력이나 파일 입력을 배열에 저장하는 방법이다. Listing 4.2는 큰 따옴표로 묶인 문자열로 배열을 초기화하는 방법과, cin을 통해 키보드로 입력한 문자열을 배열에 저장하는 방법을 설명한다. 이 프로그램은 문자열의 길이를 알아내기 위해 표준 라이브러리 함수 strlen()을 사용한다. cstring 표준 헤더 파일은 이 함수를 포함하여, 다른 많은 문자열 관련 함수들의 선언을 제공한다.
```cpp
// Listing 4.2
// strings.cpp

#include <iostream>
#include <cstring>  // strlen() 함수를 사용하기 위해
int main()
{
    using namespace std;
    const int Size = 15;
    char name1[Size];       // 빈 배열
    char name2[Size] = "C++owboy";      // 문자열 상수로 초기화된 배열
    // 참고: 어떤 C++에서는 name2 배열을 초기화하기 위해
    // static 키워드를 사용해야 한다.

    cout << "안녕하세요! 저는 " << name2;
    cout << "입니다! 실례지만 성함이?\n";
    cin >> name1;
    cout << "아, " << name1 << "씨! 당신의 이름은 ";
    cout << strlen(name1) << "자입니다만 \n";
    cout << sizeof(name1) << "바이트 크기의 배열에 저장되었습니다.\n";
    cout << "이름이 " << name1[0] << "자로 시작하는군요.\n";
    name2[3] = '\0';            // null
    cout << "제 일므의 처음 세 문자는 다음과 같습니다: ";
    cout << name2 << endl;
    return 0;
}
```
### 프로그램 분석
Listing 4.2에서 우리는 무엇을 배울 수 있을까? 먼저 sizeof 연산자가 배열의 전체 크기를 15바이트라고 알려준다. 그러나 strlen() 함수는 배열의 전체 크기가 아니라 배열에 저장된 문자열의 크기를 리턴한다. strlen()함수는 널문자는 제외하고 눈에 보이는 문자들만 헤아려 Basicman의 길이로 9가 아닌 8을 리턴한다. 일반적으로 cosmic이 문자열이라면, 그 문자열을 저장할 수 있는 배열의 최소 크기는 strlen(cosmic) + 1이다.<br><br>
Listing 4.2 프로그램은 배열 크기를 기호 상수로 나타내고 있다. 배열 크기는 프로그램의 여기저기에 흩어져 있는 여러 구문에서 사용되는 경우가 많다. 배열 크기를 기호 상수로 나타내면, 나중에 배열 크기를 바꾸어야 할 때 프로그램을 수정하기가 쉽다. 기호 상수가 정의된 곳에서 한 번만 값을 바꾸면 된다.<br><br>
## 문자열 입력
Listing 4.2에서 발생하는 결함을 Listing 4.3을 통해 알아보고 문자열 입력이 쉽지 않을 수 있다는 것을 보여준다.
```cpp
// Listing 4.3
// instr1.cpp
#include <iostream>
int main()
{
    using namespace std;
    const int ArSize = 20;
    char name[ArSize];
    char dessert[ArSize];

    cout << "이름을 입력하십시오: \n";
    cin >> name;
    cout << "좋아하는 디저트를 입력하십시오: \n";
    cin >> dessert;
    cout << "맛있는 " << dessert;
    cout << "디저트를 준비하겠습니다. " << name" << "님!\n";
    return 0;
}
```
Listing 4.3 프로그램의 의도는 단순하다. 사용자의 이름과 좋아하는 디저트를 키보드로 입력받아 그 정보를 화면에 다시 출력하는 것이다.<br>
이 프로그램은 디저트를 입력하라는 프롬프트에 응답할 수 있는 기회를 주지 않는다. 디저트를 입력하라는 프롬프트를 출력한 다음, 멈추지를 않고 곧 바로 마지막 줄까지 출력해 버리기 때문이다.<br><br>
이렇게 되는 이유는 cin이 문자열의 끝을 인식하는 방법 때문이다. 키보드로는 끝내기 널 문자를 입력할 수 없기 때문에, cin에게 문자열의 끝을 알려주는 다른 수단이 필요하다. 그렇기 때문에 cin은 빈칸, 탭, 캐리지 리턴과 같은 화이트 스페이스가 있으면 그 위치에서 문자열이 끝난 것으로 간주한다. 즉, char형의 배열에 저장하기 위해 키보드로부터 입력을 받을 때 cin은 하나의 단어만 읽어 그것을 배열에 저장하고 널 문자를 끝에 추가한다.<br><br>
## 한 번에 한 행의 문자열 입력 읽기
한 번에 한 단어씩 문자열 입력을 읽는 것은 바람직한 선택이 아니다. 예를 들어 프로그램이 사용자에게 도시 이름을 입력할 것을 요청하고, 사용자가 ***New York, Sao Paulo***라고 응답한다고 가정하자. 이러한 경우에 사용자는 프로그램이 New, Sao만이 아닌 전체를 읽기를 원할 것이다. 이를 문자열로 입력하려면 다른 방법이 필요하다. 즉, 단어 단위의 문자열 입력이 아닌, 행 단위의 문자열 입력이 필요하다. 다행히 istream 클래스가 행 단위로 문자열을 입력하는 클래스 멤버 함수인 getline()과 get()을 제공한다. 둘 다 전체 입력 행을 읽는다. 즉, 개행 문자가 나올 때까지 읽는다. 그러나 getline()은 개행 문자를 읽어서 폐기하는 반면에 get()은 입력 큐에 개행 문자를 남겨둔다. getline()부터 시작하여 알아보자.<br><br>
### getline()을 이용한 행 단위 입력
getline()함수는 Enter키에 의해 전달되는 개행 문자를 입력의 끝으로 간주하여 한 행 전체를 읽는다. cin.getline()을 함수 호출로 사용함으로써 이 메서드를 호출할 수 있다. 이 함수는 두 개의 매개변수를 사용한다. 첫 번째 매개변수는 입력한 행을 저장할 배열의 이름이다. 두 번째 매개변수는 입력받을 문자들의 한계이다. 한계가 20이면 이 함수는 최대 19개까지 문자들을 입력받을 수 있다. 나머지 한 자리는 널 문자를 위해 예비해 두는 것이다. getline()멤버 함수는 한계에 도달하거나 한계 이전이라도 개행 문자를 읽으면 읽기를 중단한다.<br><br>
예를 들어, getline() 함수로 이름을 읽어 20개의 원소를 가진 name 배열에 저장하고 싶다면 다음과 같은 호출을 사용할 수 있다.
```cpp
cin.getline(name, 20);
```
이 구문은 한 행 전체를 읽어, name 배열에 저장한다. 이때 그 행에 있는 문자들의 개수는 최대 19개 또는 그보다는 적어야 한다. Listing 4.4는 Listing 4.3을 cin 대신에 cin.getline()을 사용하도록 수정한 것이다.
```cpp
// Listing 4.4
// instr2.cpp
#include <iostream>
int main()
{
    using namespace std;
    const int ArSize = 20;
    char name[ArSize];
    char dessert[ArSize];

    cout << "이름을 입력하십시오: \n";
    cin.getline(name, ArSize);
    cout << "좋아하는 디저트를 입력하십시오: \n";
    cin.getline(dessert, ArSize);
    cout << "맛있는 " << dessert;
    cout << "디저트를 준비하겠습니다. " << name" << "님!\n";
    return 0;
}
```
이 프로그램은 이름이 빈칸으로 분리되어 있어도 온전하게 하나로 읽는다. 또한 좋아하는 디저트를 입력할 기회도 준다. getline()함수는 편리하게 한 행을 한 번에 읽는다. 이 함수는 행의 끝을 표시하는 개행 문자까지 읽는다. 그러나 개행 문자는 저장하지 않는다. 개행문자는 널 문자로 대체하여 저장한다.<br><br>

### get()을 이용한 행 단위 입력
istream 클래스는 또 다른 멤버 함수인 get()을 제공한다. 이 함수는 여러 변종이 있다. 그중의 하나가 getline() 함수처럼 동작한다. 그것은 같은 매개변수를 사용하고, 매개변수를 같은 방식으로 해석하며, 행의 끝까지 읽는다. 그러나 이 함수는 개행 문자를 읽어서 버리지 않고 입력 큐에 그대로 남겨둔다. get()을 연달아 두 번 호출한다고 가정해보자.
```cpp
cin.get(name, ArSize);
cin.get(dessert, ArSize);       // 문제 발생
```
첫 번째 호출이 입력 큐에 개행 문자를 그대로 남겨 두기 때문에, 두 번째 호출은 그 개행 문자를 첫 문자로 만나게 된다. 그래서 get()은 읽을 것도 없이 곧 바로 행의 끝에 도달했다고 결론을 내린다. 따라서 특별한 조치를 취해 주지 않는 한 get()은 개행 문자를 넘어갈 수가 없다.<br><br>
다행히 get()의 한 변종으로부터 도움을 받을 수 있다. cin.get()호출은 그것이 개행 문자이든 아니면 다른 무엇이든 간에 무조건 문자 하나를 읽는다.
```cpp
cin.get(name, ArSize);          // 첫 번째 행을 읽는다.
cin.get();                      // 개행 문자를 읽는다.
cin.get(dessert, ArSize);       // 두 번째 행을 읽는다.
```
get()을 사용하는 또 한 가지 방법은 두 개의 클래스 멤버 함수를 결합하여 사용하는 것이다. 즉, 다음과 같이 사용한다.
```cpp
cin.get(name, ArSize).get();        // 멤버 함수들을 결합한다.
```
이와 같이 사용하면 cin.get(name, ArSize)가 cin객체를 리턴한다. 리턴된 cin 객체는 뒤에 결합된 get() 함수를 호출하는 객체로 사용된다. 이와 비슷한 원리로
```cpp
cin.getline(name1, ArSize).getline(name2, ArSize);
```
두 행의 입력을 연속해서 읽어 name1과 name2 배열에 각각 저장한다. 이것은 cin.getline()을 두 번 호출하는 것과 같다.

Listing 4.5는 멤버 함수의 결합을 사용하고 있다. 이 기능을 클래스 정의에 활용하는 방법은 추후에 알아볼 것이다.
```cpp
// Listing 4.5
// instr3.cpp
#include <iostream>
int main()
{
    using namespace std;
    const int ArSize = 20;
    char name[ArSize];
    char dessert[ArSize];

    cout << "이름을 입력하십시오.\n";
    cin.get(name, ArSize).get();    // 문자열, 개행문자를 읽는다.
    cout << "좋아하는 디저트를 입력하십시오: \n";
    cin.get(dessert, ArSize).get();
    cout << "맛있는 " << dessert;
    cout << " 디저트를 준비하겠습니다." << name << "님!\n";
    return 0;
}
```
C++에서는 매개변수 리스트를 다르게 하면 같은 이름을 가진 함수의 여러 변종을 사용할 수 있다. 예를 들어, cin.get(name, ArSize)를 사용하면 컴파일러는 문자열을 읽어 배열에 저장하라는 뜻으로 알고 그에 알맞은 멤버 함수를 호출한다.그렇지 않고 매개변수를 리스트가 없는 cin.get()을 사용하면, 컴파일러는 문자 하나를 읽으라는 뜻으로 알아듣는다. 이와 같이 매개변수 리스트를 다르게 하여 같은 이름의 함수를 여러 벌 만드는 것을 함수의 오버로딩이라고 한다.<br>
getline() 대신에 get()을 사용하는 이유는 무엇일까? 첫째, 구식 C++에는 getline()이 없기 때문이다. 둘째, get()이 사용자를 다소 신중하게 만들기 때문이다. 예를 들어 한 행을 저장하기 위해 get()을 사용했다고 가정하자. get()이 배열의 수납 범위를 벗어나지 않는 전체 행을 읽어들였는지 어떻게 알 수 있을까? 이것은 그 다음 입력 문자를 살펴보면 된다. 그것이 개행 문자이면 행 전체를 다 읽은 것이고, 그것이 개행문자가 아니라면 그 행에 여전히 읽을것이 남아 있는 것이다. 쉽게 말해 getline()은 사용하기가 좀 더 편하고, get()은 에러 체킹이 더 쉽다. 어느 것이나 한 행의 입력을 읽어들이는 데 사용할 수 있다. 단지 약간 다르게 행동한다는 것만 기억하자<br><br>
### 빈 행과 기타 문제점
getline()이나 get()이 빈 행을 읽은 후에는 무슨 일이 일어날까? 원래는 마지막으로 사용된 getline()이나 get()이 남겨 두고 떠난 자리를 그 다음 입력으로 구문이 승계하는 것이었다. 그러나 현재는 get()이 빈 행을 읽으면 failbit라는 것이 설정된다. 이 행동이 뜻하는 것은 계속되는 입력을 막고, 입력을 복원하려면 다음과 같은 명령을 사용해야 한다는 것이다.
```cpp
cin.clear();
```
잠재적으로 발생할 수 있는 또 하나의 문제점은 입력 문자열이 대입된 공간보다 더 길 수 있다는 것이다. 입력 행이 지정된 문자 수보다 길면, getline()과 get()은 나머지 문자들을 입력 큐에 그대로 남겨둔다. 그러나 부가적으로 getline()은 failbit를 설정하고 더 이상의 입력을 받지 않는다.<br><br>
## 문자열과 수치의 혼합 입력
행 단위의 문자열 입력과 수치 입력을 혼합하여 사용하면 문제가 발생할 수 있다. Listing 4.6을 살펴보자
```cpp
// Listing 4.6
// numstr.cpp
#include <iostream>
int main()
{
    using namespace std;
    cout << "지금 사시는 아파트에 언제 입주하셨습니까?\n";
    int year;
    cin >> year;
    cout << "사시는 도시를 말씀해 주시겠습니까?\n";
    char address[80];
    cin.getline(address, 80);
    cout << "아파트 입주 연도: " << year << endl;
    cout << "도시: " << address << endl;
    cocut << "등록이 완료되었습니다!\n";
    return 0;
}
```
이 프로그램은 주소를 입력할 기회를 주지 않는다. cin이 입주 연도를 읽어들이고 Enter키가 만들어 내는 개행 문자를 입력 큐에 남겨 두기 때문에 발생하는 문제이다. cin.getline()은 입력 큐에 남겨진 개행 문자를 빈 행으로 읽어들이고, address 배열에 널 문자열을 대입한다. 이 문제를 해결하는 방법은 주소를 읽기 전에 개행 문자를 읽어 허공에다 버리는 것이다. 매개변수를 사용하지 않는 get()이나, 하나의 char형 매개변수를 사용하는 get()을 호출한느 것을 포함하여 여러 가지 방법으로 이 문제를 해결할 수 있다. 이 호출은 다음과 같이 별개의 구문으로 사용할 수 있다.
```cpp
cin >> year;   
cin.get();      또는 cin.get(ch);
```
또는 cin >> year가 cin객체를 리턴한다는 사실을 이용하여 cin >> year에 결합하여 사용할 수도 있다.
```cpp
(cin >> year).get();        // 또는 (cin >> year).get(ch);
```
Listing 4.6에 이들 중의 하나를 적용하면, 프로그램이 원래 의도한 대로 동작할 것이다.<br>
C++ 프로그램은 문자열을 처리하기 위해 배열 대신에 포인터를 더 많이 사용한다. 포인터로 문자열을 처리하는 방법은 포인터에 대해 조금이라도 언급한 다음에 공부하겠다.<br><br>
# strting 클래스
string 클래스를 사용하려면, 프로그램에 string 헤더 파일을 포함시켜야 한다. string 클래스는 std 이름 공간에 속해 있으므로, using 지시자를 사용하러나 std::string를 사용하여 그 클래스를 참조해 주어야 한다. 이 클래스 정의는 문자열의 배열 성질을 보이지 않게 감춤으로써, 문자열을 보통의 변수처럼 취급할 수 있게 한다. Listing 4.7은 string 객체와 문자 배열의 몇 가지 유사점과 차이점에 대해 설명한다.
```cpp
// Listing 4.7
// strtype1.cpp
#include <iostream>
#include <string>
int main()
{
    using namespace std;
    char charr1[20];        // 빈 배열 생성
    char charr2[20]; = "jaguar";    // 초기화된 배열 생성
    string str1;            // 빈 string 객체를 생성
    string str2 = "panther";    // 초기화된 string 객체를 생성

    cout << "고양이과의 동물 한 종을 입력하십시오: ";
    cin >> charr1;
    cout << "고양이과의 또 다른 동물 한 종을 입력하십시오: ";
    cin >> str1;        // 입력을 위해 cin 사용
    cout << "아래 동물들은 모두 고양이과입니다: \n";
    cout << charr1 << " " << charr2 << " "
        << str1 << " " << str2 << endl;  // 출력을 위해 cout 사용
    cout << charr2 << "에서 세 번째 글자: " << charr2[2] << endl;
    cout << str2 << "에서 세 번째 글자: " << str2[2] << endl;   // 배열 표기 사용
    return 0;
}
```
이 예제에서는 문자 배열과 string 객체를 동일한 방식으로 사용가능하다는 사실을 알 수 있다.
* C 스타일의 문자열로 string 객체를 초기화할 수 있다.
* cin을 사용하여 string 객체에 키보드 입력을 저장할 수 있다.
* cout을 사용하여 string 객체를 디스플레이 할 수 있다.
* 배열 표기를 사용하여 string 객체에 저장되어 있는 개별적인 문자들에 접근할 수 있다.

Listing 4.7이 보여 주는 string객체와 문자 배열의 가장 큰 차이점은 string 객체를 배열이 아니라 단순한 변수로 선언하는 것이다.
```cpp
string str1;
string str2 = "panther";
```
이 클래스 설계는 크기 문제를 프로그램이 자동으로 처리하도록 허용한다. 예를 들면 str1 선언은 길이가 0인 string 객체를 생성한다. 그러나 이 프로그램은 입력을 읽어 str1에 넣을 때 str1의 크기를 자동으로 조절한다.
```cpp
cin >> str1;
```
이 때문에 string 객체를 사용하는 것이 배열을 사용하는 것보다 편리하고 안전하다. 개념적으로, char형의 배열은 char형 저장 단위의 집합체라고 생각할 수 있고, string 클래스 변수는 문자열을 나타내는 하나의 실체라고 생각할 수 있다.<br><br>
## 대입, 결합, 추가
string 클래스는 배열보다 조작이 간단하다. 예를 들면, 하나의 배열을 다른 배열에 간단하게 대입할 수 없지만, 하나의 string 객체를 다른 string객체에 간단하게 대입할 수 있다.
```cpp
char charr1[20];        // 빈 배열 생성
char charr2[20] = "jaguar"; // 초기화된 배열 생성
string str1;    // 빈 string 객체 생성
string str2 = "panter";     // 초기화된 string 객체 생성
charr1 = charr2;            // 틀리다. 배열 대입 X
str1 = str2;                // 맞다. 객체 대입 O
```
string 클래스는 문자열 결합을 간단하게 처리한다. +연산자를 사용하여 두 개의 string 객체를 하나로 결합할 수 있고, +=연산자를 사용하여 기존의 string객체의 끝에 또 다른 string 객체를 덧붙일 수 있다. 앞의 예제를 갖고 설명한다면 다음과 같은 조작들이 가능하다.
```cpp
string = str3;
str3 = str1 + str2;     // 결합된 두 string 객체를 str3에 대입
str1 += str2;           // str1의 끝에 str2 추가
```
Listing 4.8은 이와 같은 용법들을 설명한다. string 객체 뿐만 아니라 C 스타일 문자열도 string 객체에 결합하고 추가할 수 있다는 사실에 주목하라
```cpp
// Listing 4.8
// strtype2.cpp
#include <iostream>
#include <string>
int main()
{
    using namespace std;
    string s1 = "penguin";
    string s2, s3;

    cout << "string 객체를 string 객체에 대입할 수 있다: s2 = s1\n";
    s2 = s1;
    cout << "s1: " << s1 << ", s2: " << s2 << endl;
    cout << "string 객체에 C스타일 문자열을 대입할 수 있다.\n";
    s2 = "buzzard";
    cout << "s2: " << s2 << endl;
    cout << "string 객체들을 결합할 수 있다: s3 = s1 + s2\n";
    s3 = s1 + s2;
    cout << "s3: " << s3 << endl;
    cout << "string 객체들을 추가할 수 있다.\n";
    s1 += s2;
    cout << "s1 += s2 --> s1 = " << s1 << endl;
    s2 += "for a day";
    cout << "s2 += \"for a day\" --> s2 = " << s2 << endl;
    return 0;
}
```
<br>

## string 클래스의 조작
C++에 string 클래스가 추가되기 전에도, 프로그래머들은 문자열 대입과 같은 조작들을 수행할 필요가 있었다. 그들은 C라이브러리에 있는 함수들을 사용하여 C스타일의 문자열들을 대상으로 이러한 조작들을 수행하였다. cstring 헤더파일이 이 함수들을 지원한다. 예를 들면, strcpy()함수를 사요하여 문자열을 문자 배열에 복사할 수있고, strcat() 함수를 사용하여 문자열을 문자 배열에 추가할 수 있다.
```cpp
strcpy(charr1, charr2);     // charr2를 charr1에 복사
strcat(charr1, charr2);     // charr2의 내용을 charr1에 추가
```
Listing 4.9는 string 객체에 사용되는 테크닉과 문자 배열에 사용되는 테크닉을 비교한다.
```cpp
// Listing 4.9
// strtype3.cpp
#include <iostream>
#include <string>
#include <cstring>
int main()
{
    using namespace std;
    char charr1[20];
    char charr2[20] = "jaguar";
    string str1;
    string str2 = "panther";

    // string 객체으 ㅣ대입과 문자 배열의 대입
    str1 = str2     // str2를 str1에 복사
    strcpy(charr1, charr2);     // charr2를 charr1에 복사

    // string 객체의 추가와 문자 배열의 추가
    str1 += " paste";       // str1의 끝에 paste를 추가
    strcat(carr1, " juice");        // charr1의 끝에 juice를 추가

    // string 객체의 길이 구하기와 C 스타일 문자열의 길이 구하기
    int len1 = str1.size()          // str1의 길이를 구한다.
    int len2 = strlen(charr1);      // charr1의 길이를 구한다.

    cout << str1 << " 문자열에는 " << len1 << "개의 문자가 들어 있다.\n"
    cout << charr1 << " 문자열에는 " << len2 << "개의 문자가 들어 있다.\n";
    return 0;
}
```
일반적으로 string 객체를 사용하는 것이 C 문자열 함수를 사용하는 것보다 간단하다. 복잡한 문자열 조작의 경우에는 특별히 더 그러하다. 예를 들면, 다음과 같은 string 객체 조작을
```cpp
str3 = str1 + str2;
```
라이브러리 함수로 동등하게 구현하면 다음과 같이 된다.
```cpp
strcpy(charr3, charr1);
strcat(charr3, charr2);
```
게다가 배열을 다루는 경우에는 다음 예와 같이, 목적지 배열이 너무 작아 정보를 모두 담을 수 없는 상황이 발생활 위험이 항상 존재한다.
```cpp
char site[10] = "house";
strcat(site, " of pancakes");       // 메모리 문제 발생
```
strcat()함수는 site배열에 모두 12개의 문자를 복사하려고 시도를 할 것이다. 결과적으로 인접한 메모리를 침범한다. 이것은 프로그램을 먹통으로 만들거나, 잘못된 데이터를 가지고 실행되도록 만든다. string 클래스는, 필요하면 크기를 자동으로 조절하여 이와 같은 종류의 문제를 피한다. C라이브러리는 strcat(), strcpy()와 같은 계통으로 strcat(), strcpy()를 제공한다. 이들은 타깃 배열의 최대 허용 크기를 나타내느 세 번째 매개변수를 사용함으로써 더 안전하게 동작하지만, 그들을 사용한다는 것은 프로그램을 작성할 때 한층 복잡해진다는 것을 의미한다.<br>
문자열에 있는 문자들의 수를 구하는데 서로 다른 문법이 사용된 것에 주목하라.
```cpp
int len1 = str1.size();     // str1의 길이를 구한다.
int len2 = strlen(charr1);  // charr1의 길이를 구한다.
```
strlen()함수는 C스타일 문자열을 매개변수로 사용하고, 그 문자열에 들어있는 문자들의 개수를 리턴하는 표준 함수이다. size()함수도 기본적으로 같은 일을 한다. 그러나 사용하는 문법이 다르다. str1이 함수의 매개변수로 나타나지 않고, 함수 이름 앞에 오고, 함수 이름과 도트로 연결된다. 3장 put() 메서드에서 설명했듯이 이 문법은 str1이 객체를 나타내고, size()가 클래스 메서드라는 것을 나타낸다. 메서드는, 그 메서드와 같은 클래스에 속한 객체에 의해서만 호출될 수 있는 함수이다. 이 특별한 경우에 str1은 string 객체이고, size()는 string메서드이다. 요약하면 C함수들은 매개변수를 사용하여 어느 문자열을 사용할 것인지를 나타낸다. C++의 string 클래스 객체는 객체 이름과 도트 연산자를 사용하여 어느 문자열을 사용할 것인지를 나타낸다.<br><br>
## string 클래스의 입출력
지금까지 보았듯이, C 스타일 문자열에 사용하는 것과 동일한 문법으로 cin을 >> 연산자와 함께 사용하여 string 객체를 읽을 수 있고, cout를 << 연산자와 함께 사용하여 string 객체를 출력할 수 있다. 그러나 한 번에 한 단어가 아닌 행을 읽을 때에는 다른 문법을 사용한다. Listing 4.10이 이 차이를 설명한다.
```cpp
// Listing 4.10
// strtype4.cpp
#include <iostream>
#include <string>
#include <cstring>
int main()
{
    using namespace std;
    char charr[20];
    string str;

    cout << "입력 이전에 charr에 있는 문자열의 길이: "
    << strlen(charr) << endl;
    cout << "입력 이전에 str에 있는 문자열의 길이: "
    << str.size() << endl;
    cout << "텍스트 한 행을 입력하십시오: \n";
    cin.getline(charr, 20);     // 최대 길이를 나타낸다.
    cout << "입력한 텍스트: " << charr << endl;
    cout << "또 다른 텍스트 한 행을 입력하십시오: \n";
    getline(cin, str);      // 이제 cin은 길이 지정자가 아니라 매개변수
    cout << "입력한 텍스트: " << str << endl;
    cout << "입력 이후에 charr에 있는 문자열의 길이: " << strlen(charr) << endl;
    cout << "입력 이후에 str에 있는 문자열의 길이: " << str.size() << endl;
    return 0;
}
```
프로그램은 입력 이전에 charr 배열에 있는 문자열의 길이가 27이라고 출력한다. 이것은 배열의 크기보다도 더 크다. 여기서 알아둘 것은 첫째, 초기화하지 않은 배열의 내용은 정의되지 않는다. 둘째, strlen() 함수는 배열의 첫 번째 원소에서 출발하여 널 문자에 도달할 때 까지의 바이트들을 카운트한다. 이 경우에 배열의 끝을 몇 바이트 지나치고 나서야 첫 널 문자가 나타난다. 초기화되지 않는 데이터에서 첫 널 문자가 나타나는 위치는 본질적으로 랜덤하다. 따라서 위의 프로그램은 실행할 때마다 값이 달라질 수 있다.<br>
입력 이전에 str에 들어 있는 문자열의 길이가 istream 클래스를 위한 클래스 메서드 라는 것을 나타낸다. 앞에서 언급했듯이 첫 번째 매개 변수는 목적지 배열을 나타내고, 두 번째 매개변수는 배열의 크기를 나타낸다. getline()은 배열의 경계를 벗어나지 않도록 하는 데 이 크기를 사용한다.<br>
한 행을 읽어 string 객체 안에 얺는 코드는 다음과 같다.
```cpp
getline(cin, str);
```
여기에는 도트 표시가 없다. 이것으로 이 getline()이 클래스 메서드가 아니라는 것을 알 수 있다. 이 getline()은 입력을 어디에서 찾을 것인지를 나타내는 매개변수로 cin을 사용한다. 또한 string 객첸는 문자열에 맞게 문자열의크기를 자동으로 조절하기 때문에 여기에는 문자열의 크기를 나타내는 매개변수가 없다.<br><br>
왜 하나의 getline()은 istream 클래스 메서드이고, 다른 하나의 getline()은 그렇지 않을까? istream클래스는 string 클래스가 추가되기 오래 전부터 C++의 일부였다. 그래서 istream 설계는 double, int와 같은 C++ 기본 데이터형들을 인식하지만, string형은 인식하지 못한다. 그러므로 double, int 및 기타 다른 기본 데이터형들을 처리하는 istream 클래스 메서드들은 있지만, string 객체를 처리하는 istream 클래스 메서드는 없다.<br>
string 객체를 처리하는 istream 클래스 메서드가 없기 때문에 다음과 같은 코드가 어떻게 동작하는지 궁금할 것이다.
```cpp
cin >> str;     // 한 단어를 읽어 string 객체 str안에 넣는다.
```
다음과 같은 코드는
```cpp
cin >> s;       // 한 값을 읽어 C++ 기본 데이터형에 넣는다.
```
istream 클래스의 멤버 함수를 사용한다. 그러나 그 앞의 string 클래스 코드는 string 클래스의 프렌드 함수를 사용한다. 프렌드 함수가 무엇이고, 이 테크닉이 어떻게 동작하는지는 추후에 공부하도록 하자.<br><br>

# 구조체
파이썬의 Dict 자료형처럼 모든 정보를 하나의 단위로 묶을 수 있는 데이터 형식이 C++에도 존재한다. 이는 구조체(structure)라고 하는데, 서로 관련된 정보를 하나의 단위로 묶어서 저장할 수 있다. 하나의 구조체 안에 여러 종류의 데이터를 저장할 수 있기 때문에 배열보다 융통성이 있다.<br>
구조체는 사용자가 정의할 수 있는 데이터형이다. 데이터형의 특성을 정의하는 구조체 선언이 필요하다. 데이터형을 정의한 후에는 그 데이터형의 변수를 생성할 수 있다. 그러므로 구조체는 두 단계를 거쳐 생성된다. 첫 번째는 구조체 서술(structure description)을 정의하는 단계이다. 이 단계에서는 구조체 안에 저장할 여러 가지 데이터형들을 서술하고 이름을 정한다. 두 번째는 구조체 서술에 따라 구조체 변수(structure variable)를 생성하는 단계이다. 좀 더 일반적으로 말하면, 구조체 데이터 객체를 생성하는 단계이다.<br>
예를 들어, 어떤 장난감 회사에서 생산하고 있는 모형풍선 제품들에 대한 정보를 나타낼 수 있는 데이터형을 원한다고 가정하자. 특별히 그 데이터형은 제품명, 부피, 가겨 등을 나타낼 수 있어야 한다. 다음은 이러한 요구를 만족시키는 구조체 서술이다.
```cpp
struct inflatable   // 구조체 선언
{
    char name[20];
    float volume;
    double price;
};
```
여기서 키워드 struct는 이 코드가 구조체 서술을 정의하고 있다는 것을 나타낸다. 태그라고도 보르는 식별자 inflatable은 새로 만들어지는 데이터형의 이름으로 사용된다. char형 변수나 int형 변수를 생성하듯이, 이제부터는 inflatable형의 변수를 생성할 수 있다. 중괄호 {}안에는 이 구조체를 구성하는 데이터형들의 리스트를 넣는다. 이 리스트에 나열되는 각 항목은 선언 구문이다. 이 리스트에는 배열이나 다른 구조체를 포함하여, C++가 제공하는 어떠한 데이터형도 넣을 수 있다. 이 리스트의 각 항목을 멤버(member)라고 부른다.
그리고 예제의 마지막 부분을 보면 세미콜론을 사용하여 템플릿 선언을 끝내는 것을 볼 수 있다.<br>
템플릿을 만든 다음에는 그 데이터형의 변수들을 생성할 수 있다.
```cpp
inflatable hat;     // inflatable형의 구조체 변수
inflatable woopie_cushion   // inflatable형의 구조체 변수
inflatable mainframe    // inflatable형의 구조체 변수
```
C언어에서는 구조체 변수를 선언할 때 키워드 struct를 요구한다. 그러나 C++에서는 키워드 struct를 생략할 수 있다.
```cpp
struct inflatable goose // C는 키워드 struct를 요구한다.
inflatable vincent;     // C++는 키워드 struct를 요구하지 않는다.
```
C++에서는 구조체 태그를 기본 데이터형의 이름처럼 사용할 수 있다. 이러한 변화는 구조체 선언이 새로운 데이터형을 정의하는 것임을 강조하는 것이다. 또한 키워드 struct를 생략해도 에러가 발생하지 않는다.<br>
hat가 inflatable형이라면, 멤버 연산자(.)를 사용하여 그 구조체의 개별적인 멤버에 접근할 수 있다. 예를 들어, hat.volume은 hat변수의 volume 멤버를 나타내고, hat.price는 hat변수의 price멤버를 나타낸다. 이와 마찬가지로 vincent.price는 vincent 변수의 price 멤버를 나타낸다. 쉽게 말해서, 배열 인덱스를 이용하여 배열 원소에 접근할 수 있듯이, 멤버 이름을 사용하여 구조체의 멤버에 접근할 수 있다. price 멤버는 double형으로 선언되었기 때문에, hat.price와 vincent.price는 둘 다 double형 변수와 모든 면에서 동등하다. 따라서 보통의 double형 변수처럼 사용할 수 있다. 정리하자면 hat은 구조체이고, hat.price는 double형 변수이다. 클래스 멤버 함수에 접근하는 cin.getline()과 같은 방법은 구조체 멤버 변수에 접근하는 vincent.price와 같은 방법에서 그 형식을 차용하였다.<br><br>
## 프로그램에 구조체 사용하기
지금까지 구조체의 주요 특징을 알아보았으므로, 구조체를 사용하는 프로그램 안에 그 아이디어를 구현해 볼 차례이다. Listing 4.11은 구조체의 이러한 요점들에 대해 설명한다. 또한 구조체를 초기화하는 방법도 설명한다.
```cpp
// Listing 4.11
// structur.cpp
#include <iostream>
struct inflatable
{
    char name[20];
    float volume;
    double price;
};

int main()
{
    using namespace std;
    inflatable guest = 
    {
        "Glorious Gloria",  // name 값
        1.88,               // volume 값
        29.99               // price 값
    };                      // guest는 inflatable형의 구조체 변수이다.
                            // 지정된 값으로 초기화된다.
    inflatable pal = 
    {
        "Audacious Arthur",
        3.12,
        32.99
    };                      // pal은 inflatable형의 두 번째 변수이다.
    // 참고: 어떤 C++ 시스템에서는 다음과 같은 형식을 요구한다.
    // static inflatable guest = 

    cout << "지금 판매하고 있는 모형 풍선은\n" << guest.name;
    cout << "와 " << pal.name << "입니다.\n";
    // pal.name은 pal 변수의 name 멤버이다.
    cout << "두 제품을 $";
    cout << guest.price + pal.price << "에 드리겠습니다!\n";
    return 0;
}
```
## 프로그램 분석
Listing 4.11 프로그램과 관련하여 한 가지 중요한 것은 구조체 선언을 두는 위치이다. structur.cpp에서는 두 가지 방법을 사용할 수 있다. 첫 번째 방법은 main() 함수의 안에 여는 중괄호 바로 뒤에 선언을 두는 것이다. 두 번째 방법은 이 예제처럼 main()함수의 앞에 선언을 두는 것이다. 함수의 밖에 선언을 두는 것을 외부 선언(external declaration)이라 한다. 이 예제에서는 선언이 함수의 안에 있든 밖에 있든 차이가 없다. 그러나 여러 개의 함수로 이루어지는 프로그램에서는 커다란 차이가 날 수 있다. 즉, 외부 선언은 이후에 나오는 모든 함수들이 사용할 수 있으나, 내부 선언은 그 선언이 들어 있는 함수에서만 사용할 수 있다. 일반적으로 프로그래머들은 모든 함수들이 구조체를 사용할 수 있도록 구조체를 외부적으로 선언하고 있다.<br>
또한 변수도 내부적으로 또는 외부적으로 선언할 수 있다. 외부 변수는 여러 함수들이 공유할 수 있다. C++의 일반적인 관행은 외부 변수의 사용은 가급적 금지하고 외부 구조체 선언은 장려한다. 그것은 기호 상수를 외부적으로 선언하는 것과도 일맥상통한다.<br><br>
이제 초기화 과정을 살펴보자
```cpp
inflatable guest = 
{
        "Glorious Gloria",  // name 값
        1.88,               // volume 값
        29.99               // price 값
    };
```
배열과 마찬가지로, 한 쌍의 중괄호 {} 안에 초기화 값들이 콤마로 구분되는 초기화 리스트를 넣는다. 이 예제 프로그램에서는 한 행에 하나의 값을 나타냈지만, 모든 값들을 한 행에 나타낼 수도 있다. 그러나 초기화 값들을 콤마로 구분해야한다.
```cpp
inflatable duck = {"Daphne", 0.12, 9.98};
```
구조체의 각 멤버는 자신의 데이터형에 맞는 값으로 초기화할 수 있다. 예를 들어, name 멤버는 char형의 배열이므로, 문자열로 초기화할 수 있다.<br>
구조체의 각 멤버는 그 데이터형의 변수처럼 취급된다. 그래서 pal.price은 char형의 배열이므로, cout을 사용하여 pal.name을 출력하면 문자열로 출력된다. 또한 인덱스를 사용하여 pal.name 배열 내의 각 문자들에 접근할 수 있다.즉, pal.name[0]은 문자 A이다. pal은 배열이 아니라 구조체이기 때문에 pal[0]은 아무런 의미가 없다.<br><br>
## 구조체의 기타 특성
C++에서는 사용자가 정의한 데이터형을 내장 데이터형과 동일한 방식으로 다룰 수 있다. 예를 들어, 구조체를 함수에 매개변수로 전달할 수 있으며, 구조체를 리턴값으로 사용할 수도 있다 대입 연산자(=)를 사용하여 하나의 구조체를 같은 데이터형의 다른 구조체에 대입할 수 있다. 이때에는 한 구조체의 멤버 값들이 상대방 구조체의 해당 멤버에 각각 대입된다. 이때 배열도 대입되는 하나의 멤버가 될 수 있다. 이와 같이 멤버 단위로 대입되는 것을 멤버별 대입(memberwise assignment)이라 한다.
```cpp
// Listing 4.12
// assgn_st.cpp
#include <iostream>
struce inflatable
{
    char name[20];
    float volume;
    double price;
};
int main()
{
    using namespace std;
    inflatable bouquet = 
    {
        "sunflowers",
        0.20,
        12.49
    };
    inflatable choice;
    cout << "bouquet: " << bouquet.name << " for $";
    cout << bouquet.price << endl;
    
    choice = bouquet;
    cout << "choice: " << choice.name << " for $";
    cout << choice.price << endl;
    return 0;
}
```
실행 결과에서 볼 수 있듯이, 멤버별 대입을 통하여 bouquet 구조체의 멤버 값들이 choice 구조체의 멤버들에 각각 대입되었다. 구조체 템플릿의 정의와 구조체 변수의 생성을 하나로 결합할 수 있다. 그렇게 하려면 다음과 같이 중괄호 뒤에 변수 이름을 둔다.
```cpp
struct perks
{
    int key_number;
    char car[12];
} mr_smith, ms_jones;
```
이러한 방식으로 변수를 생성할 때 초기화도 함께 처리할 수 있다.
```cpp
struct perks
{
    int key_number;
    char car[12];
} mr_glitz =
{
    7, "Packard"
};
```
그러나 구조체 템플릿의 정의와 구조체 변수의 선언을 분리해 놓는 것이 프로그램을 더 이해하기 쉽게 만든다.<br>
데이터형 이름이 없는 구조체를 생성할 수도 있다. 이것은 태그 이름을 생략하고 템플릿과 변수를 동시에 생성하는 것이다.
```cpp
struct          // 태그가 없다
{
    int x;      // 두 개의 멤버
    int y;
} position;     // 구조체 변수
```
이것은 position이라는 구조체 변수를 생성한다. position.x와 같이 멤버 연산자를 사용하여 멤버에 접근할 수는 있지만, 데이터형 이름이 없기 때문에 이후에 같은 형의 다른 변수를 생성할 수 없다.<br><br>
## 구조체의 배열
inflatable 구조체는 배열(name 배열)을 멤버로 포함하고 있다. 또한 원소가 구조체인 배열을 생성할 수도 있다. 구조체의 배열을 만드는 방법은 기본 데이터형의 배열을 만드는 것과 같다. 예를 들어, inflatable형 구조체 100개를 원소로 가지는 배열을 생성하려면 다음과 같이 정의할 수 있다.
```cpp
inflatable gifts[100];      // inflatable형 구조체 100개의 배열
```
이것은 gifts를 inflatable형의 배열로 만든다. 따라서 gifts[0] 또는 gifts[99]와 같은 배열 원소는 inflatable형 객체이다. 따라서 다음과 같이 멤버 연산자를 사용할 수 있다.
```cpp
cin >> gifts[0].volume;         // 첫 번째 구조체의 volume 멤버에 입력
cout << gifts[99].price << endl; // 마지막 구조체의 price 멤버를 출력
```
gifts 자체는 구조체가 아니라 배열이므로, gifts.price와 같은 표현은 아무런 의미가 없다.<br>
다음은 구조체의 배열을 초기화하는 방법이다.
```cpp
inflatable guests[2] =
{
    {"Bambi", 0.5, 21.99},      // 첫 번째 배열 원소인 구조체
    {"Godzilla", 2000, 565.99}  // 두 번째 배열 원소인 구조체
}
```
Listing 4.13은 구조체의 배열을 사용하는 간단한 예제를 설명한다. guset가 inflatable형의 배열이고, guest[0]이 inflatable형이기 때문에, inflatable 구조체의 멤버에 접근하기 위해 도트 연산자와 함께 그것을 사용할 수 있다.
```cpp
// Listing 4.13
// arrstruc.cpp
#include <iostream>
struct inflatable
{
    char name[20];
    float volume;
    double price;
};
int main()
{
    using namespace std;
    inflatable guests[2] =
    {
        {"Bambi", 0.5, 21.99},
        {"Godzilla", 2000, 565.99}
    };
    cout << guests[0].name << "와 " << guests[1].name << "의 부피를 합하면\n"
    << guests[0].volume + guests[1].volume << " 세제곱피트 입니다.\n";
    return 0;
}
```

# 공용체
공용체(union)은 서로 다른 데이터형을 한 번에 한 가지만 보관할 수 있는 데이터 형식이다. 즉, 구조체는 int형과 long형과 double형을 한꺼번에 보관할 수 있지만, 공용체는 int형이나 long형이나 double형 중에서 한 번에 어느 하나만 보관할 수 있다.
```cpp
union one4all
{
    int int_val;
    long long_val;
    double double_val;
};
```

one4all 변수는 int형이나 long형이나 double형을 보관할 수 있지만, 어느 한 시점에 어느 한 가지만 보관가능하다.
```cpp
one4all pail;
pail.int_val = 15;      // int형을 저장
cout << pail.int_val;
pail.double_val = 1.38;     // double형을 저장, int값은 소실
cout << pail.double_val;
```

여러 가지 데이터형을 사용할 수 는 있지만 이를 동시에 사용할 수 없을 때, 공용체를 사용하면 메모리를 절약할 수 있다.

# 열거체
C++의 enum기능은 const를 사용하여 기호 상수를 만드는 것에 대한 또 다른 방편을 제공한다. 또한 그것은 제한적이기는 하지만 새로운 데이터형을 정의할 수 있게 해준다.
```cpp
enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};
```

이 구문은 두 가지 일을 수행한다.
* spectrum을 새로운 데이터형의 이름으로 만든다. struct형 변수를 구조체라 부르듯이, enum형 변수를 열거체(enumeration)이라 부른다.
* red, orange, yellow, ... 등을 0에서 7까지의 정수 값을 각각 나타내는 기호 상수로 만든다. 이 상수들을 열거자(enumerator)라 부른다.

열거체의 이름을 사용하여 열거형의 변수를 선언할 수 있다.
```cpp
spectrum band;  // band는 spectrum형의 변수
```
열거체 변수는 특별한 특성을 가지고 있다. 열거체 변수에는 그 데이터형을 정의하는데 사용된 열거자 값들만 대입할 수 있다.
```cpp
band = blue;        // 맞다, blue는 열거자이다.
band = 2000;        // 틀리다, 2000은 열거자가 아니다.
```
따라서 spectrum형 변수에는 단지 8개의 값만 대입할 수 있다. 열거체 변수에 부당한 값을 대입하려고 시도하면 어떤 컴파일런는 컴파일러 에러를, 또 어떤 컴파일러는 경고를 발생시킨다. 이식성을 최대한 높이기 위해, 열거체 변수에 부당한 값을 대입하는 것은 에러라고 생각하라.<br>
열거체는 대입 연산자만 사용하도록 정의되어 있다. 특히, 산술 연산이 허용되지 않는다.
```cpp
band = orange;      // 맞다.
++band;             // 틀리다.
band = orange + red;    // 그럴듯하지만 틀리다.
```

열거자들은 정수형이며 int형으로 승급될 수 있다. 그러나 int형이 자동으로 열거체로 변환되지는 않는다.
```cpp
int color = blue; // 맞다, spectrum형이 int형으로 승급한다.
band = 3;           // 틀리다, int형이 spectrum형으로 변환되지 않는다.
color = 3 + red;    // 맞다, red 가 int형으로 변환된다.
```
이 예제에서 주의할 것은, 3이 열거자 green에 해당하는 값이지만, 3을 직접 band에 대입하면 데이터형 에러를 일으킨다는 사실이다. 그러나 band에 green을 대입하는 것은 당연히 허용된다.

```cpp
band = orange + red;        // 그럴듯하지만 틀리다.
```
위의 예제들을 통하면 위의 예제가 별 문제 없어보일 것이다. 하지만 위의 코드는 틀리다. 열거자들에 대해 +연산자는 정의되어 있지 않기 때문이다.<br><br>
열거체에 적용된느 규칙은 매우 제한적이다. 실제로 열거체는 새로운 데이터형을 정의하는 수단이 아니라, 상호 관련이 있는 기호 상수들을 정의하는 용도로 주로 사용된다.

# 포인터와 메모리 해제
포인터는 값 자체가 아니라 값의 주소를 저장하는 변수이다. 일반적인 변수에 대해 명시적으로 그 주소르 알아내는 방법은 변수 앞에 주소 연산자(&)을 붙이면 그 변수의 주소를 알아낼 수 있다.
```cpp
// Listing 4.14
// address.cpp
#include <iostream>
int main()
{
    using namespace std;
    int donuts = 6;
    double cups = 4.5;

    cout << "donuts의 값 = " << donuts;
    cout << ", donuts의 주소 = " << &donuts << endl;
    
    // 참고: unsigned (&donuts)와 unsigned (&cups)를 사용할 것을 요구하는 경우도 있다.

    cout << "cups의 값 = " << cups;
    cout << ", cups의 주소 = " << &cups << endl;
    return 0;
}
```
위 프로그램에서 주소값은 16진수로 나타나게 된다. 16진수 표기가 메모리를 나타내는 가장 일반적인 방법이기 때문에 cout의 주소 표현은 16진수를 사용한다. 또한 주소값의 차이를 살펴보면 8바이트가 차이나는 것을 볼 수 있다. 이는 double형 변수이므로 이치에 맞는 것이다.

## 포인터와 C++의 철학
```
객체 지향 프로그래밍은 컴파일 시간(compile time)이 아닌 실행 시간(rumtime)에 어떤 결정을 내린다는 것을 강조하는 점에서 재래 절차적 프로그래밍과는 다르다. 실행 시간이라는 것은 프로그램이 실제로 실행되는 동안을 의미한다. 반면에 컴파일 시간은 컴파일러가 소스코드를 실행코드로 변환하는 시간을 말한다. 실행 시간에 결정을 내리는 것은 휴가 동안에 그날의 날씨와 기분에 따라 여행지를 임의로 바꾸는 것과 같다. 컴파일 시간에 결정을 내리는 것은 그러한 조건과는 관계없이 미리 예정된 스케줄에 따라 여행을 강행하는 것과 같다.

그러므로 실행 시간 결정이 그때그때 상황에 적절히 대처할 수 있는 융통성을 갖는다.

C++에서 배열을 선언하려면 배열의 크기를 미리 정해야 한다. 즉, 컴파일할 때 배열의 크기가 미리 결정된다. 이것이 바로 컴파일 시간 결정이다. 그런데 그 배열의 원소 개수가 대부분의 경우에 20개면 충분하지만, 200개가 필요한 경우가 간혹 있다고 가정해보자. 이러한 상황에서는 어쩔 수 없이 안전을 위해 원소 개수가 200개인 배열을 사용해야 한다. 이렇게 되면 평상시에 메모리를 크게 낭비하는 꼴이 된다. 객체 지향 프로그래밍에서는 실행 시간까지 이러한 결정을 미룸으로써 프로그램에 융통성을 부여한다. 원소가 20개가 필요한지 아니면 205개가 필요한지는 프로그램이 실행될 때 사용자가 프로그램에 알려줄 수 있다.
```

일반 변수를 사용할 떄와는 반대로, 저장된 데이터를 다루는 새로운 전략은 주소를 이름을 붙인 양으로 취급하고 값을 파생되는 양으로 취급한다. 그래서 포인터라는 특별한 데이터형의 변수에 어떤 값의 주소를 저장한다. 즉, 포인터의 이름이 주소를 나타낸다. 간접값(indirect value) 연산자 또는 간접 참조(dereferencing) 연산자라고 부르는 *를 포인터 이름 앞에 붙이면 그 주소에 저장되어 있는 값이 된다. manly가 포인터라고 가정하자. 이와 같은 경우에 manly는 주소를 나타내고, *manly는 그 주소에 저장되어 있는 값을 나타낸다. *manly는 보통의 int형 변수와 동등하게 취급된다.
```cpp
// Listing 4.15
// pointer.cpp
#include <iostream>
int main()
{
    using namespace std;
    int updates = 6;            // int형 변수를 선언
    int * p_updates;            // int형을 지시하는 포인터를 선언

    p_updates = &updates;       // int형의 주소를 포인터에 대입
}
```
int형 변수 updates와 포인터 변수 p_updates는 동전의 양면과도 같다. updates 변수는 값을 우선적으로 나타내고, 여기에 & 연산자를 적용하여 주소를 알아낸다. p_updates포인터 변수는 주소를 우선적으로 나타내고, 여기어 * 연산자를 사용하여 값을 알아낸다.

## 포인터의 선언과 초기화
포인터를 선언하는 과정을 살펴보자. 컴퓨터는 포인터가 지시하는 값의 데이터형을 추적할 필요가 있다. 예를 들어, char형 값의 주소와 double형 값의 주소는 같아보여 서로를 구별할 수 없다. 그러나 char형 값과 double형 값은 저장되는 바이트 수가 다르고, 저장 형식도 다르다. 그러므로 포인터를 선언할 때에는 그 포인터가 지시하는 데이터형이 무엇인지 서술해야한다.<br>
예를 들면, 앞의 예제에서 다음과 같은 선언 구문을 사용했다.
```cppcpp
int * p_updates;
```
이 구문은 * p_updates가 int형이라는 것을 나타낸다. *연산자를 포인터에 적용하여 사용하기 때문에 p_updates는 포인터가 아니라 int형 변수이다.<br><br>
\*연산자의 앞뒤에는 빈칸이 있어도 되고 없어도 된다. 전통적으로 C프로그래머들은 다음과 같은 형식을 사용한다.
```cpp
int &ptr;
```
이것은 *ptr가 int형이라는 것을 강조한다. 그러나 C++ 프로그래머들은 다음과 같은 형식을 사용하고 있다.
```cpp
int* ptr;
```
이것은 int* 자체가 하나의 데이터형임을 강조한다. 그것은 int형을 지시하는 포인터이다. 컴파일러는 * 연산자의 앞이나 뒤에 있는 빈칸을 무시한다. 그러나 다음과 같은 선언 구문은
```cpp
int* p1, p2;
```
p1을 포인터 변수로, p2를 보통의 int형 변수로 생성한다. 그러므로 p1과 p2를 모두 포인터 변수로 만드려면 각각의 포인터 변수 이름 앞에 * 연산자를 따로 사용해야 한다.

```cpp
// Listing 4.16
// init_ptr.cpp
#include <iostream>
int main()
{
    using namespace std;
    int higgens = 5;
    int * pt = &higgens;
    cout << "higgens의 값 = " << higgens
    << ", higgens의 주소 = " << &higgens << endl;
    cout << "*pt의 값 = " << *pt
    << ", pt의 값 = " << pt << endl;
    return 0;
}
```
여기에서는 *pt가 아니라 pt가 higgens의 주소로 초기화되었음을 알 수 있다.

## 포인터의 위험
```cpp
long * fellow;      // long형을 지시하는 포인터 생성
*fellow = 223322;   // 어딘지 알 수 없는 곳에 값을 저장
```
여기서 fellow는 포인터이다. 그런데 이 포인터가 어디를 지시하고 있는지는 알 수가 없다. 왜냐하면 fellow에 주소를 대입하는 단계를 빠뜨렸기 때문이다. 그렇다면 도대체 223322는 어디어 저장되었을까? 이것은 아무도 모른다. fellow를 초기화하지 않았기 때문에 fellow에는 지금 엉뚱한 값이 들어있을 것이다. 프로그램은 그 값이 무엇이든 간에 223322를 저장할 주소라고 생각한다.

## new를 사용한 메모리 대입
포인터가 어떻게 동작하는지 알아보았다. 이번에는 프로그램을 실행하는 동안에 메모리를 대입하는 객체 지향 프로그래밍의 중요한 테크닉을 살펴보자. 지금까지는 포인터들을 변수의 주소로 초기화하였다. 이때 각 포인터는 이름에 의해 직접 접근할 수 있는 메모리를 위핸 대용 이름을 단순히 제공한다. 그러나 프로그램을 실행하는 동안에 이름이 없는(unnamed) 메모리를 대입하는 것이 포인터의 진정한 가치이다. 이 경우에는 포인터가 그 메모리에 접근할 수 있는 유일한 통로이다.<br><br>
프로그램을 실행하는 동안에 int형 값을 저장할 수 있는 이름이 없는 메모리를 대입하고, 포인터를 사용하여 그 메모리에 접근하는 새로운 방법을 알아보자. 여기서는 new 연산자가 중요한 역할을 한다. 어떤 데이터형의 메모리를 원하는지 new 연산자에게 알려 주면, new 연산자는 그에 알맞은 크기의 메모리 블록을 찾아내고 그 블록의 주소를 리턴한다. 이 주소를 포인터에 대입하면 된다.
```cpp
int* pn = new int;
```
new int 부분은 int형 데이터를 저장할 새로운 메모리가 필요하다고 프로그램에게 알린다. new연산자는 뒤따르는 데이터형을 보고, 몇 바이트가 필요한지를 파악한다. 그러고 나서 적당한 메모리를 찾아 필요한 만큼 블록을 대입하고, 그 주소를 리턴한다. 이제 리턴되는 주소는 int형을 지시하는 포인터로 선언되어 있는 pn에 대입된다. 여기서 pn은 주소이고 *pn은 그 주소에 저장되는 값이다.<br>
기본 데이터형일 수도 있고 구조체일 수도 있는 어떤 단일 데이터 객체를 저장하기 위해 메모리를 확보하고, 그 주소를 포인터에 대입하는 일반적인 형식은 다음과 같다.
```cpp
typeName * pointer_name = new typeName;
```
여기서는 데이터형을 두 번 사용한다. 한 번은 요구하는 메모리의 종류를 지정하기 위해 사용하고, 다른 한 번은 적당한 포인터를 선언하기 위해 사용한다. 적당한 데이터형을 지시하는 포인터가 이미 선언되어 있는 경우에는 포인터를 새로 선언할 필요 없이 그 포인터를 사용할 수 있다.
```cpp
// Listing 4.17
// use_new.cpp
#include <iostream>
int main()
{
    using namespace std;
    int nights = 1001;
    int * pt = new int;     // int형을 저장할 메모리를 대입
    * pt = 1001;            // 대입된 메모리에 값을 저장

    double *pd = new double // double형을 저장할 메모리를 대입
    *pd = 10000001.0        // 그 메모리에 double형 값을 저장
    return 0;
}
```
int형 데이터 객체와 double형 데이터 객체를 저장할 메모리를 new를 사용하여 각각 대입한다. new를 사용한 이러한 메모리 대입은 프로그램이 실행되는 동안에 일어난다. 포인터 pt와 pd가 두 데이터 객체를 각각 지시한다. 이등 포인터를 사용하지 않고는 그 메모리 위치에 접근할 수 없다. *pt, *pd를 마치 변수처럼 사용할 수 있다. *pt, *pd에 값을 대입하면 새로 만들어진 그 데이터 객체에 값이 대입된다. 마찬가지로 *pt와 *pd를 출력하면 그 데이터 객체의 값이 출력된다.

## delete를 사용한 메모리 해제
필요할 때 new를 사용하여 메모리를 대입하는 것은 C++의 강력한 메모리 관리 기능의 절반에 불과하다. 나머지 절반은 사용한 메모리를 다시 메모리 풀로 환수하는 delete 연산자이다. 이것은 메모리를 가장 효율적으로 사용하기 위한 중요한 절차이다. 이렇게 환수한 또는 해제한 메모리는 프로그램의 다른 부분이 다시 사용할 수 있다. delete는 new로 대입한 메모리 블록을 지시하는 포인터화 함께 사용한다.
```cpp
int* ps = new int;      // new로 메모리 대입
delete ps               // delete로 메모리 해제
```

## new와 delete를 사용할 때의 규칙
* new로 대입하지 않은 메모리는 delete로 해제하지 않는다.
* 같은 메모리 블록을 연달아 두 번 delete로 해제하지 않는다.
* new []로 메모리를 대입한 경우에는 delete []로 해제한다.
* new를 대괄호 없이 사용했으면 delete도 대괄호 없이 사용한다.
* 널 포인터에는 delete를 사용하는 것이 안전하다.

```cpp
// Listing 4.18
// arraynew.cpp
#include <iostream>
int main()
{
    using namespace std;
    double * p3 = new double [3];

    p3[0] = 0.2;
    p3[1] = 0.5;
    p3[2] = 0.8;

    cout << p3[0] << endl;

    p3 = p3 + 1;        // 포인터를 증가시킨다.
    cout << p3[0] << endl;

    p3 = p3 - 1;        // 다시 시작 위치를 지시한다.
    cout << p3[0] << endl;

    delete [] p3;       // 배열 메모리 해제
    return 0;
}
```
### 출력 결과
```
0.2
0.5
0.2
```
여기서 볼 수 있듯이, arraynew.cpp는 포인터 p3을 마치 배열 이름처럼 사용하여, 첫 번째 원소를 p3[0]으로 나타냈다.

# 포인터, 배열, 포인터 연산
포인터와 배열 이름의 동등성은 C++가 내부적으로 배열을 처리하는 방법과, 포인터 연산으로부터 온다. 먼저 포인터 연산에 대해 알아보자. 정수형 변수에 1을 더하면 값이 1만큼 증가한다. 그러나 포인터 변수에 1을 더하면 값이 그 포인터가 지시하는 데이터형의 바이트 수만큼 증가한다. 예를 들어, double형이 8바이트인 시스템에서, double형을 지시하는 포인터에 1을 더하는 것은 그 포인터의 수치 값에 8을 더하는 것과 같다. 또한 short형이 2바이트인 시스템에서, short형을 지시하는 포인터에 1을 더하는 것은 그 포인터의 값에 2를 더하는 것과 같다.
```cpp
// Listing 4.19
// addpntrs.cpp
#include <iostream>
int main()
{
    using namespace std;
    double wages[3] = {10000.0, 20000.0, 30000.0};
    short stacks[3] = {3, 2, 1};

    // 배열의 주소를 알아내는 두 가지 방법
    double * pw = wages;        // 배열 이름 = 주소
    short * ps = &stacks[0];    // 배열 원소에 주소 연산자 사용

    cout << "pw = " << pw << ", *pw = " << *pw << endl;
    pw = pw + 1;
    cout << "pw 포인터에 1을 더함: \n";
    cout << "pw = " << pw << ", *pw = " << *pw << "\n\n";

    cout << "ps = " << ps << ", *ps = " << *ps << endl;
    ps = ps + 1;
    cout << "ps 포인터에 1을 더함: \n";
    cout << "ps = " << ps << ", *ps = " << *ps << "\n\n";

    cout << "배열 표기로 두 원소에 접근\n";
    cout << "stacks[0] = " << stacks[0]
    << ", stacks[1] = " << stacks[1] << endl;
    cout << "포인터 표기로 두 원소에 접근\n";
    cout << "*stacks = " << *stacks
    << ", *(stacks + 1) = " << *(stacks + 1) << endl;

    cout << sizeof(wages) << " = wages 배열의 크기\n";
    cout << sizeof(pw) << " = pw 포인터의 크기\n";
    return 0;
}
```
## 포인터에 관한 요약
포인터에 대해서 약간이나마 배웠다.
### 포인터 선언
특정 데이터형을 지시하는 포인터를 선언하려면 다음과 같은 형식을 사용한다.
```cpp
typeName * pointerName;
ex)
double * pn;        // pn은 double형 값을 지시할 수 있다.
char * pc;          // pc는 char형 값을 지시할 수 있다.
```
여기서 pn과 pc가 포인터이다. C++에서는 double형을 지시하는 포인터를 double *로 표기하고, char형을 지시하는 포인터를 char *로 표기한다.

### 포인터에 값 대입
포인터에는 메모리 주소를 대입해야 한다. 변수 이름에 &연산자를 사용하면 이름이 있는 메모리의 주소를 얻을 수 있다. new 연산자는 이름이 없는 메모리의 주소를 리턴한다.
```cpp
double * pn;        // pn은 double형 값을 지시할 수 있다.
double * pa;        // pa는 double형 값을 지시할 수 있다.
char * pc;          // pc는 char형 값을 지시할 수 있다.
double bubble = 3.2 
pn = &bubble;       // bubble의 주소를 pn에 대입한다.
pc = new char;      // 새로 대입된 char형 메모리의 주소를 pc에 대입한다.
pa = new double[30] // double형 30개 배열의 주소를 pa에 대입한다.
```
### 포인터의 간접 참조
포인터의 간접 참조는 포인터가 지시하는 주소에 저장되어 있는 값을 참조한다는 뜻이다. 간접 값(indirect value) 연산자 또는 간접 참조(dereferencing) 연산자라 부르는 * 연산자를 포인터에 적용하면, 그 포인터가 지시하는 주소에 저장되어 있는 값을 참조할 수 있다.
```cpp
cout << *pn;        // bubble의 값을 출력한다.
*pc = 'S';          // 주소가 pc인 메모리 위치에 값 'S'를 대입한다.
```

### 포인터와 참조값의 구별
pt가 int형을 지시하는 포인터라면, *pt는 int형을 지시하는 포인터가 아니라 int형 변수와 완전히 동등한 것이다.
```cpp
int * pt = new int;     // 포인터 pt에 주소를 대입한다.
*pt = 5;                // 그 주소에 값 5를 저장한다.
```

### 배열 이름
대부분의 경우에 C++는 배열 이름을 그 배열의 첫 번째 원소의 주소와 동등한 것으로 취급한다.
```cpp
int tacos[10];      // tacos는 &tacos[0]과 동등하다.
```

### 포인터 연산
C++에서는 포인터에 정수를 더할 수 있다. 포인터에 1을 더하는 것은 원래의 주소 값에 그 포인터가 지시하는 데이터 객체의 크기를 더하는 것과 같다. 반대로 포인터에서 정수를 뺄 수도 있다.
```cpp
int tacos[10] = {5, 2, 8, 4, 1, 2, 2, 4, 6, 8};
int * pt = tacos;           // pt와 tacos가 주소 3000이라고 가정할 때
pt = pt + 1;                // int형이 4바이트이면, 이제 pt는 3004이다.
int * pe = &tacos[9];       // int형이 4바이트이면, pe는 3036이다.
pe = pe - 1;                // 이제 pe는 tacos[8]의 주소인 3032이다.
int diff = pe - pt          // diff는 tacos[8]과 tacos[1]의 간격 7이다.
```

### 배열의 동적 바인딩과 정적 바인딩
정적 바인딩으로 배열 크기가 고정된 배열을 생성할 때에는 배열 선언 구문을 사용할 수 있다.
```cpp
int tacos[10];      // 정적 바인딩, 컴파일 시간에 크기가 정해진다.
```
동적 바인딩으로 동적 배열을 생성할 때에는 new 연산자를 사용한다. 동적 바인딩에서는 프로그램이 실행될 때 배열의 크기가 정해지고 메모리를 대입받는다. 배열을 사용하는 작업이 끝나면 delete[]로 메모리를 해제해야 한다.
```cpp
int size;
cin >> size;
int* pz = new int [size];       // 실행 시간에 크기가 정해지는 동적 바인딩
delete  [] pz;                  // 작업이 끝나면 메모리를 해제한다.
```

### 배열 표기와 포인터 표기
대괄호를 사용하는 배열 표기는 포인터를 사용하는 간접 참조와 의미상 동등하다.
```cpp
tacos[0]은 *tacos와 동등하다. 이들은 tacos 주소에 있는 값을 의미한다.
tacos[3]은 *(tacos + 3)과 동등하다. 이들은 tacos + 3 주소에 있는 값을 의미한다.
```
이와 같은 동등성은 배열 이름과 포인터 변수 둘 다에 해당된다. 
