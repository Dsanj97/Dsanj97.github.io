---
layout: single
title: "Start C++"
categories: TIL
---
# C++ 시작
하나의 메시지를 출력하는 간단한 C++ 프로그램을 통해서 C++로의 긴 여행을 떠나보자.
Listing 2.1은 C++의 cout 기능을 사용하여 문자를 출력하고 있다.  
C++의 주석문은 //로 시작한다. 컴파일러는 주석문을 무시하고 건너뛴다. C++은 대, 소문자를 구별한다. 따라서 cout을 Cout이나 COUT으로 표기하게되면 컴파일러가 알 수 없다.  
```cpp
// myfirst.cpp
#include <iostream>         // 선행처리 지시자
int main(){                 // 함수 머리, 함수 몸체의 시작
    using namespace std;    // 정의 가시화
    cout << "Welcome C++";  // 메시지 출력
    cout << endl;           // 새로운 행 시작
    cout << "My first C++" << endl; // 또 다른 메시지 출력
    return 0;               // main()을 종료
}                           // 함수 몸체의 끝
```  

main 함수의 역할을 살펴보면 main() 앞에 오는 전처리 지시자와 같은 것들을 이해하기가 더 쉽기 떄문에, main() 함수가 무엇을 하는지부터 알아보자.
* ## main() 함수
군더더기를 떼어버리면 Listing 2.1은 다음과 같은 기본 구조로 되어 있다.
```cpp
int main()
{
    구문들
    return 0;
}
```  
이것을 살펴보면 main() 이라는 함수가 있다는 사실과, 그 함수가 어떠한 동작을 처리하는 것인지 알 수 있다. 이것은 두 부분으로 이루어져 있는데 이들이 함수 정의(function definition)을 구성한다. 첫 번째 행에 있는 int main()이라는 부분이 함수 머리(function header)이고, 중괄호({})로 묶여 있는 부분이 함수 몸체(function body)이다. 함수 머리는 이 함수를 프로그램의 다른 부분과 연결하는 고리 역할을 하고, 함수 몸체는 그 함수가 처리하는 동작들을 컴퓨터에게 지시하는 역할을 한다. 컴퓨터에게 내리는 지시(instruction)를 구문(statement)이라고 하는데 C++에서 모든 구문은 세미콜론으로 끝나야 한다.  
main() 함수의 끝에 있는 구문은 return 구문이다. 이것은 함수를 종료하는 역할을 한다. return 구문에 대해서는 나중에 다시 알아보자.

* ## 인터페이스 역할을 하는 함수 머리
main() 함수의 정의가 함수 머리 int main()으로부터 시작한다는 사실을 알아보았다. 함수 머리의 문법에 대해 조금 알아보자.  
일반적으로 함수는 다른 함수에 의해 호출된다. 이때 함수 머리는 호출 함수와 피호출 함수의 인터페이스를 나타낸다. 함수 이름의 앞부분을 함수 리턴형(function return type)이라고 한다. 이것은 피호출 함수가 호출 함수로 다시 넘겨주는 정보의 흐름을 나타낸다. 함수 이름 뒤에 있는 괄호 한의 부분을 인자 리스트(argument list) 또는 매개변수 리스트(parameter list)라고 한다. 이것은 호출 함수가 피호출 함수로 넘겨주는 정보의 흐름을 나타낸다. 이러한 일반 규칙이 main() 함수에서는 다소 혼동된다. 그 이유는 프로그램 어디에도 main() 함수를 호출하는 부분이 없기 때문이다. 일반적으로 main()은, 프로그램과 운영체제를 중개하기 위해 컴파일러가 프로그램에 추가하는 시동코드에 의해 호출된다. 따라서 이 함수 머리는 main()과 운영 체제 사이의 인터페이스를 나타낸다.  
main()을 위한 인터페이스를 살펴보자. 먼저 int 부터 보자. 다른 함수에 의해 호출된 함수는 자신을 호출한 함수에게 값을 리턴할 수 있다. 이 값을 리턴값(return value)이라 한다. 앞의 예제에서 main() 함수는 정수값을 리턴할 수 있다. 키워드 int를 보고 이 사실을 알 수 있다.  
다음은 빈 괄호에 대해 알아보자. 일반적으로 어떤 함수가 다른 함수를 호출할 때 정보도 함께 전달할 수 있다. 함수 머리의 괄호 안에 있는 부분이 이 정보를 나타낸다. 이 예제의 경우에 괄호 안이 비어 있는 것은 main() 함수가 어떤 정보도 전달받지 않는다는 것을 뜻한다. 이것을 프로그래밍 전문 언어로 말하면, main()이 어떠한 parameter도 요구하지 않는다는 것을 의미한다.  
간단히 말해, 다음과 같은 함수 머리는  
```cpp
int main()
```  

main() 함수가 자신을 호출한 함수로부터 어떠한 정보도 전달받지 않지만, 그 함수에게 정수값을 리턴한다는 것을 나타낸다.  
많은 기존의 프로그램들이 클래식C의 함수 머리를 사용하고 있다.
```cpp
main()  // 클래식 C의 함수 머리 스타일
```  
클래식 C에서, 리턴형을 생략하는 것은 그 함수가 int형이라고 말하는 것과 같다. 그러나 C++는 이와 같은 용법을 폐기했다. 또한 다음과 같이 사용할 수도 있다.
```cpp
int main(void)  // 아주 명시적인 스타일
```  
괄호 안에 키워드 void를 사용하는 것은 그 함수가 다른 함수로부터 어떠한 것도 전달받지 않는다는 것을 명시적으로 밝히는 것이다. c++에서 괄호 안을 비워 두는 것은 괄호 안에 void가 있는 것과 같다.  
어떤 프로그래머들은 다음과 같은 스타일의 함수 머리를 사용하고 리턴 구문을 생략한다.
```cpp
void main()
```  
void 리턴형이 함수가 값을 리턴하지 않는다는 것을 뜻하기 때문에, 이것은 논리적으로 타당하다. 그러나 이러한 스타일이 일부 시스템에서는 잘 동작하더라도, C++ 표준은 아니므로 어떤 시스템에서는 동작하지 않는다. 그러므로 이러한 스타일을 사용하는 것을 피하고 C++ 표준을 사용해야 한다. 그렇게 하는데 수고가 많이 드는 것도 아니다.  
끝으로 main()의 끝에 리턴 구문을 두어야 한다는 성가신 강요에 대해 불평하는 사람들에게 ISO C++ 표준은 한발 양보한다. 컴파일러가 리턴 구문을 만나지 못한채 main()의 끝에 도달하면 다음과 같은 구문으로 main()을 끝내는 것과 동일한 효과를 낸다.
```cpp
return 0;
```  

* ## 이름이 반드시 main() 이어야 하는 이유
모든 C++ 프로그램은 maini() 함수로부터 실행을 개시한다. myfirst.cpp 프로그램에는 함수가 하나만 존재하므로 그 함수가 main() 함수의 역할도 해야 한다. 프로그램에 main() 함수가 없으면 완전한 프로그램이 아니다. 이러한 경우에 컴파일러는 main() 함수를 정의하지 않았다고 지적할 것이다.  
그러나 예외도 있다. 예를 들어 Windows 프로그래밍에서 동적 링크 라이브러리(DLL) 모듈을 작성할 때가 그렇다. DLL모듈은 다른 Windows 프로그램들이 사용할 수 있는 코드로서, 독립된 프로그램이 아니므로 main()이 필요 없다. 로봇의 컨트롤러 칩과 같은 특수한 환경에서는 main() 이 필요하지 않을 수도 있다. 그러나 일반적인 독립형 프로그램에는 반드시 main()이 필요하다.

* ## C++ 주석문
더블 슬래시(//) 뒤에는 항상 C++의 주석문이 온다. 주석문은 프로그래머가 프로그램 안에 기록해 두는 일종의 메모로, 프로그램의 구역을 구분하거나 코드의 어떤 부분이 무슨 역할을 하는 것인지 표시하는데 사용한다. 컴파일러는 이 주석문을 아예 무시하고, 주석문이 아닌 것만을 컴파일 하기 때문에 주석문의 내용을 결코 볼 수 없다. 결과적으로 Listing 2.1 프로그램은 컴파일러에게 다음과 같이 주석문 없이 작성된 것처럼 보인다.
```cpp
#include <iostream>         
int main(){                 
    using namespace std;    
    cout << "Welcome C++";  
    cout << endl;           
    cout << "My first C++" << endl; 
    return 0;               
}                          
```  
C++의 주석문은 더블슬래시에서 그 행의 끝까지이다.

* ## C++ 전처리기와 iostream 파일
여기서 알아야 할 사항이 있다. C++의 일반적인 입출력 기능을 사용하려면 다음 두 행을 프로그램에 꼭 넣어야 한다.
```cpp
#include <iostream>
using namespace std;
```  
위 두 번째 라인은 몇 가지 대체 방법이 있는데, 지금은 단순하게만 넘어간다.  
C와 마찬가지로 C++도 전처리기(preprocessor)를 사용한다. 전처리기는 컴파일을 하기 전에 소스 파일에 대해 미리 어떤 처리를 수행하는 프로그램이다.  
이름이 #로 시작되는 것은 전처리 지시자(directive)라고 부른다. 전처리기는 특별히 따로 호출하는 것이 아니라 소스 파일을 컴파일할 때 자동으로 실행된다.
```cpp
#include <iostream> // 전처리 지시자
```  
이 지시자는 전처리기에게 iostream 파일의 내용을 프로그램에 추가하라고 지시한다. 이와 같이 컴파일 되기 전에 소스 코드에 텍스트를 추가하거나 텍스트를 대체하는 것이 전처리기가 수행하는 기본적인 역할이다.  
그런데 iostream파일의 내용을 왜 프로그램에 포함해야 할까? 그 이유는 프로그램과 바깥 에상이 정보를 주고받을 수 있도록 하기 위해서다. iostream의 i는 입력(input), o는 출력(output)을 나타낸다. iostream 파일에는 C++의 몇 가지 입출력 기능이 정의되어 있다. 프로그램에서 cout 가능을 사용하려면 이러한 정의가 필요하다 #include 지시자는 프로그램 안에 있는 #include <iostream\>이라는 행이 iostream 파일의 내용으로 대체된다. 사용자가 작성한 소스 파일은 변경되지 않은 채 그대로 유지되고, 소스 파일과 iostream의 결합 파일이 컴파일의 다음 단계로 넘어간다.

* ## 헤더 파일 이름
iostream과 같은 파일을 포함 파일(다른 파일에 포함된다는 의미에서), 또는 헤더 파일(파일의 앞부분에 들어간다는 의미에서)이라고 부른다. C++ 컴파일러는 많은 헤더 파일을 제공한다. 각각의 헤더 파일은 특정 부류의 기능을 지원한다. C에서는 헤더 파일의 이름만 보고도 파일 유형을 알 수 있도록 헤더 파일에 h 확장자를 사용했다. 예를 들어 C의 math.h 헤더 파일은 여러 가지 수학 함수들을 지원했다.  
C++의 헤더 파일에는 확장자를 사용하지 않는다. C 헤더 파일이 C++ 헤더 파일로 진화한 것도 있는데 그러한 헤더 파일들은 .h확장자를 빼고 이름의 앞부분에 c를 넣는다.

* ## 이름 공간
iostream.h 대신에 iostream을 사용할 때, 프로그램이 iostream의 정의를 사용할 수 있게 하려면 다음과 같은 이름 공간 지시자를 활용해야 한다.
```cpp
using namespace std;
```  
이것을 using 지시자(directive)라 부른다는 정도만 알고 나중에 자세히 공부하도록 하자.  
이름 공간은 C++의 가장 새로운 기능이다. 이름 공간은 프로그램을 작성할 때 여러 소프트웨어 개발업체들이 제공하는 코드들을 사용할 수 있도록 도와준다. 예를 들어, 두 업체의 제품을 사용해야 하는데 두 제품에 모두 wanda()라는 함수가 들어 있다면, 컴파일러에는 어느 제품의 wanda()를 사용해야 할지 판단할 수 없게 된다. 이와 같은 경우에 한 업체의 패키지를 이름 공간(namespace)이라는 하나의 단위로 포장하여 나타낼 수 있다. 이를 테면 Microflop Industries라는 회사가 만든 제품에 대해서는 Microflop이라는 이름 공간으로 포장하여, 그 회사의 wanda() 함수에 Microflop::wanda()라는 이름을 사용한다. 다른 예로 Piscine Corporation 회사가 만든 wanda() 함수에 Piscine::wanda()라는 이름을 사용한다. 그러면 컴파일러는 두 가지 버전을 확실하게 구분할 수 있다.
```cpp
Microflop::wanda("go dancing?");        // Microflop 이름 공간의 버전
Piscine::wanda("a fish named Desire");  // Piscine 이름 공간의 버전
```  
이러한 방식에 의해, C++ 컴파일러의 표준 구성 요소인 클래스, 함수 ,변수는 std라는 이름 공간 안에 담겨진다. 이와 같은 일은 .h 확장자가 없는 헤더 파일들 안에서 일어난다. 예를 들어, 이것은 출력하는데 사용되고 iostream 헤더 파일 안에 정의되어 있는 cout 변수가 실제로는 std::cout으로 호출되고, end이 실제로는 std::endl이라는 것을 의미한다. 그래서 사용자는 using 지시자를 생략하고 다음과 같은 스타일로 코드를 작성할 수 있다.
```cpp
std::cout << "C++의 세계로 오십시오.";
std::cout << std::end;
```  
그러나 iostream.h와 cout을 사용하는 이름 공간 이전의 소스 코드를 iostream과 std::cout을 사용하는 이름 공간 소스 코드로 변환하는 일이 번거롭다면 대부분의 사용자들이 이러한 변환을 달가워하지 않을 것이다. 이때 사용하는 것이 using 지시자이다. 다음과 같은 행을 소스 코드에 넣으면 std:: 접두어를 붙이지 않고도 std이름 공간에 정의되어 있는 이름들을 사용할 수 있다.
```cpp
using namespace std;
```  
using 지시자는 std 이름 공간에 들어 있는 모든 이름을 사용할 수 있게 해준다. 요즘에는 이 방식을 게으른 것으로 간주하고, using 선언이라는 것을 사용하여 자신에게 필요한 이름들만 선택해서 사용할 수 있게 다음과 같은 최신 방식을 선호한다.
```cpp
using std::cout;    // cout을 사용할 수 있게 만든다
using std::endl;    // endl을 사용할 수 있게 만든다
using std::cin;     // cin을 사용할 수 있게 만든다
```  
std::를 cin과 cout에 직접 붙이지 않고, 아래와 같이 사용할 수도 있다.
```cpp
using namespace std;    // 게으른 방식, 모든 이름을 사용할 수 있다.
```  
그러나 이 최신 방식에서 iostream에 들어 있는 이름들을 사용하려면, 그 다른 이름들을 using 리스트에 개별적으로 추가해야 한다.  
* ## cout을 이용한 C++의 출력
이제 메시지를 어떻게 출력하는지 알아보자. myfirst.cpp 프로그램은 메시지를 출력하는 다음과 같은 구문을 사용하고 있다.
```cpp
cout << "Welcome C++";
```  
큰 따옴표 안에 들어 있는 부분이 출력할 메시지이다. C++ 에서는 큰 따옴표 안에 들어 있는 연속된 문자들을 문자열(string)이라고 부른다. 이것은 문자들이 끈처럼 하나로 이어져 보다 큰 단위를 이루고 있기 때문이다. << 표시는 구문이 그 문자열을 cout에 전달한다는 것을 뜻한다. << 표시가 나타내는 방향이 정보의 흐름을 상징한다. 그렇다면 cout은 무엇을 의미할까? cout은 문자열(string), 수(number), 문자(character)들을 포함한 여러 가지 다양한 정보들을 출력하는 방법을 알고 있는 미리 정의된 객체이다.  

* ## C++ 소스 코드의 모양
FORTRAN 과 같은 프로그래밍 언어에서는 하나의 구문이 하나의 행을 차지한다. 이러한 프로그래밍 언어에서는 캐리지 리턴(carriage return)이 구문들을 분리하는 역할을 한다.  
그러나 C++에서는 세미콜론이 구문의 끝을 표시한다. 이것은 C++에서 캐리지 리턴을 빈칸이나 탭과 같은 방식으로 자유롭게 사용할 수 있다는 것을 의미한다. 즉, C++에서는 캐리지 리턴을 사용할 수 있는 곳에 빈칸을 대신 사용할 수 있다는 뜻이다. 다시 말해서 이것은 하나의 구문을 여럴 행에 펼쳐 놓을 수도 있고, 여러 개의 구문을 한 행에 늘어 놓을 수도 있다는 것을 의미한다.  
따라서 myfirst.cpp 프로그램을 다음과 같은 모양으로 작성하는 것이 가능하다.
```cpp
#include <iostream>        
int 
main
(){               
    using 
    namespace 
    std;   cout << "Welcome C++"; cout << endl;          
    cout << "My first C++"
     << endl; return 0;              
}                          
```  
여기서 주의해야 할 점은 이름과 같은 요소의 중간에 빈칸이나 탭, 캐리지 리턴을 넣을 수 없다는 것이다.

* ## 토큰과 화이트 스페이스
한 행의 코드에서 더 이상 분리할 수 없는 기본 요소를 토큰(token)이라 한다. 일반적으로 하나의 토큰은 빈칸, 탭, 캐리지 리턴에 의하여 다음 토큰과 분리된다. 빈칸, 탭, 캐리지 리턴을 집합적으로 화이트 스페이스(white space)라고 부른다. 괄호나 콤마와 같은 일부 단일 분자들은 화이트스페이스로 분리하지 않아도 되는 토큰이다.다음의 예는 화이트스페이스를 언제 사용할 수 있고, 언제 생략할 수 있는지 보여준다.
```cpp
return0;            // 틀리다, return 0; 이어야 한다.
return(0);          // 맞다, 화이트스페이스가 생략되었다
return (0);         // 맞다, 화이트스페이스가 사용되었다
intmain();          // 틀리다, 화이트스페이스가 생략되었다
int main ();        // 맞다, ()안에 화이트스페이스가 생략되었다
int main ( );       //맞다, ( )안에 화이트스페이스가 사용되었다
```  

* ## C++ 소스 코드 스타일
C++ 프로그램은 매우 자유로운 스타일로 작성할 수 있다. 그러나 명쾌하고 정형화된 스타일로 프로그램을 작성하면 이해하기가 쉽다. 유요하기는 하지만 모양이 보기 흉한 프로그램은 무슨 내용인지 파악하기가 어렵다. 대부분의 C++ 프로그래머들은 Listing 2.1과 같은 스타일을 사용한다. 이 스타일은 다음과 같은 규칙을 따른다.
* 한 행에 하나의 구문을 사용한다.
* 함수를 여닫는 중괄호 {}에 각각 한 행을 할애한다.
* 함수 안에 들어갈 구문들은 중괄호에서 약간 오른쪽으로 들어간 위치에서 시작한다.
* 함수 이름과 괄호 사이에는 어떠한 화이트스페이스도 넣지 않는다.  

앞의 세 가지 규칙은 이해하기 쉽게 만들기 위한 것이고, 마지막 규칙은 루프와 같이 괄호를 사용하는 구성 요소와 함구를 구별하기 위한 것이다.

# C++ 구문
C++의 일부 구문들에 대해 알아보자.
Listing 2.2에는 두 종류의 새로운 구문들이 들어 있다. 하나는 변수를 선언ㄴ하는 선언 구문(declaration statement)이고, 다른 하나는 변수에 값을 대입하는 대입 구문(assignment statement)이다. 또한 이 프로그램에서는 cout을 Listing 2.1과는 다르게 사용하고 있다.

```cpp
// Listing 2.2
// carrots.cpp
#include <iostream>
int main()
{
    using namespace std;

    int carrots;

    carrots = 25;
    cout << "나는 당근을 ";
    cout << carrots;
    cout << "개 가지고 있다.";
    cout << endl;
    carrots = carrots - 1;
    cout << "아삭아삭, 이제 당근은 " << carrots << "개이다." << endl;
    return 0;
}
```
다음은 Listing 2.2 프로그램 실행 결과이다.
```
나는 당근을 25개 가지고 있다.
아삭아삭, 이제 당근은 24개이다.
```

* ## 선언구문과 변수
컴퓨터는 매우 정확하고 논리적인 기계이다. 컴퓨터에 어떤 정보를 저장하려면 그 정보가 얼마나 많은 기억 공간(memory storage)을 차지하는지 알아야 하며, 또한 그 정보가 저장될 위치도 알아야 한다. C++에서 이것을 하는 가장 쉬운 방법은 선언 구문을 사용하는 것이다. 선언 구문은 정보를 저장할 기억 공간의 형태를 지정하고, 그 위치가 어디인지 말해 주는 꼬리표(label)를 제공한다. 예를 들면 Listing 2.2 에서는 다음과 같은 선언 구문을 사용하고 있다.
```cpp
int carrots;
```
이 구문은, 하나의 정수를 저장할 수 있는 기억 공간을 프로그램이 사용할 예정이라고 선언한다. 그러면 컴파일러는 이를 위한 기억 공간을 대입하고, 그 위치가 어디인지 말해 주는 꼬리표를 붙이는 작업을 수행 한다. C++에서는 몇 가지 종류의 데이터형을 사용할 수 있는데 int형이 가장 기본적인 데이터형이다. int형은 소수부가 없는 정수(integer)를 말하며, 양의 정수와 음의 정수가 있다. int형의 크기는 사용하는 시스템에 따라 다르다. int 형을 포함한 기본적인 데이터형에 대해서는 다음에 공부해보도록 하자.  
  
그 다음으로 해야 할 일이 저장된 데이터의 이름을 선언하는 것이다. 선언 구문은 데이터형을 선언하는 것일 뿐만 아니라, 아으로 프로그램에서 그 기억 공간에 저장되어 있는 값을 carrots라는 이름으로 사용하겠다고 선언하는 것이다. 이와 같은 carrots를 변수(variable)라고 부른다. 변수라는 이름은 값이 변경될 수 있기 때문에 붙여진 이름이다. C++에서는 모든 변수를 사용하기 전에 미리 선언해야 한다. carrots.cpp에서 그 선언을 생략하면, 프로그램이 carrots를 사용하려고 시도하는 곳마다 컴파일러가 에러를 내보낸다.

* ## 대입 구문
대입 구문은 기억 위치에 어떤 값을 대입한다. 예를 들어, 다음과 같은 대입 구문은
```cpp
carrots = 25;
```
변수 carrots로 나타내는 기억 위치에 정수 25를 대입한다. 여기서 등호는 대입 연산자(assignment operator)라고 부른다. C++의 색다른 특징은 대입 연산자를 연이어 사용할 수 있다는 것이다. 예를 들어 다음과 같은 코드는 유효하다.
```cpp
int steinway;
int baldwin;
int yamaha;
yamaha = baldwin = steinway = 88;
```
앞에 나온 대입 구문은 오른쪽에서 왼쪽으로 차례대로 처리된다. 즉, 88이 steinway에 대입되고 steinway가 baldwin에 대입되고, baldwin이 yamaha에 대입되는 순서이다.

* ## cout의 새로운 사용법
```cpp
cout << carrots;
```
Listing 2.2에서 위와 같은 문법은 이전에 cout에 문자열만을 전달했던 방식과는 달리 변수를 전달하고 있다. 이것은 내부적으로 두 가지 작업을 하는것이다. 먼저 cout은 carrots를 정수 25로 대체한다. 그리고 정수 25를 적당한 출력문자 '2'와 '5'로 변환한다. 이처럼 cout은 문자열뿐만 아니라 정수도 출력할 수 있다. 별것 아닌것 같지만 정수 25를 문자열 '25'로 출력하는것은 한 줄 내에서 처리하기에는 어려움이 있는 코드라는 사실을 알것이다.

# C++의 기타 구문
구문의 예를 두 개만 더 살펴보자. Listing 2.3은 프로그램이 실행되는 동안에 사용자가 값을 입력시킬 수 있도록 아의 예제를 확장한다. 그렇게 하기 위해 이 프로그램은 cin을 사용한다. cout은 출력을 수행하는 객체인데 반하여, cin은 입력을 수행하는 객체이다. 또한 이 프로그램은 다재다능한 cout객체의 또 다른 용도를 설명한다.
```cpp
//Listing 2.3
//getinfo.cpp
#include <iostream>

int main()
{
    using namespace std;

    int carrots;

    cout << "당근을 몇 개나 가지고 있니?" << endl;
    cin >> carrots; // C++ 입력
    cout << "여기 두 개가 더 있다.";
    carrots = carrots + 2;
    // 다음 라인은 출력을 연결한다.
    cout << "이제 당근은 모두 " << carrots << "개이다."<< endl;
    return 0;
}
```
Listing 2.3의 실행 결과는 다음과 같다.
```
당근을 몇 개나 가지고 있니?
12
여기 두 개가 더 있다. 이제 당근은 모두 14개이다.
```

* ## cin 사용법
Listing 2.3의 실행 결과가 보여주듯이, 키보드로 타이핑한 값 12가 변수 carrots에 대입된다. 다음과 같은 구문이 그것을 수행한다.
```cpp
cin >> carrtos;
```
이 구문의 생김새를 보면 정보가 cin에서 carrots 쪽으로 흐르는 것으로 보인다. C++에서 출력할 때는 cout이 << 연산자를 사용하여 문자들을 출력 스트림에 삽입하고, 입력할 때에는 cin이 >> 연산자를 사용하여 입력 스트림에서 문자들을 가져온다. 가져온 정보를 저장할 변수는 >> 연산자의 오른쪽에 적는다. 입력 연산자와 출력 연산자로 >>와 << 기호를 선택한 것은 정보가 흐르는 방향을 연상시키기 위한 것이다.

* ## cout에 의한 출력의 결합
getinfo.cpp의 두 번째 새로운 기능은 네 개의 출력 구문을 하나로 결합하는 것이다. iostream 파일에는 << 연산자가 여러 개의 출력을 하나로 결합(연결)할 수 있도록 정의되어 있다.
```cpp
cout << "이제 당근은 모두 " << carrots << "개이다."<< endl;
```
이것은 문자열 출력과 정수 출력을 하나의 구문으로 결합한다. 이것의 실행 결과는 다음과 같은 세 행의 코드가 만들어 내는 결과와 동일하다. 
```cpp
cout << "이제 당근은 모두 ";
cout << carrots;
cout << "개이다.";
cout << endl;
```
또한 위에서 공부한것을 활용하여 네 행에 걸쳐 출력도 가능하다.
```cpp
cout << "이제 당근은 모두 "
    << carrots
    << "개이다."
    << endl;
```

이렇게 작성할 수 있는 이유는 C++의 자유로운 프로그램 작성 스타일이 토큰들 사이에서 캐리지 리턴과 빈칸을 바꾸어 사용하는 것을 허용하기 때문이다. 따라서 폭이 모자라 한 행에 작성할 수 없을 때 이 방법을 사용하면 편리하다.

# 함수
함수는 C++ 프로그램을 구성하는 모듈일 뿐만 아니라, C++의 OOP정의에 필수적인 사항이므로 철저히 익혀야 한다. 함수의 일부 측면은 고급스런 주제이다. 더 깊숙한 부분은 나중에 공부하도록 하고, 오늘은 함수의 기초적인 부분에 대해 공부해 보도록 하자.

* ## 리턴값이 있는 함수
리턴값이 있는 함수는 변수에 대입할 수 있는 하나의 값을 만들어 낸다. 예를 들어 C/C++ 표준 라이브러리에는 어떤 수의 제곱근을 리턴하는 sqrt()라는 함수가 있다. 가령 6.25의 제곱근을 어떤 변수에 할당해야 하는 상황일 때,
```cpp
x = sqrt(6.25);
```
여기서 sqrt(6.25)라는 표현이 sqrt() 함수를 호출(call)한다. 이 sqrt(6.25)를 함수 호출(function call)이라 하고, 이것에 의해 호출되는 sqrt() 함수를 피호출 함수(called function)라 한다. 또한, 함수 호출이 들어 있는 함수를 호출 함수(calling function)라 한다.  
괄호 안에 있는 값(6.25)이 함수에 전달되는 값이다. 이러한 방식으로 함수에 전달되는 값을 매개변수(argument) 또는 매개변수(parameter)라 한다.  
함수를 사용하기 전에 C++ 컴파일러는 그 함수가 어떤 종류의 매개변수를 사용할 것이며, 어떤 종류의 리턴값을 리턴하는지 미리 알고 있어야 한다. 즉, 리턴값이 정수인지, 문자인지, 소수부가 있는지 아니면 True/False문인지 등을 미리 알고 있어야 한다.  
sqrt() 함수의 원형은
```cpp
double sqrt(double);
```
이다. 리턴값이 double 형이기 때문에 위에서 작성한 코드의 변수 x의 리턴값도 double로 선언해주어야 한다.  
프로그램 작성시 sqrt()와 같은 함수들을 사용하려면 함수 원형을 제공해야 하는데 이때 이 원형을 제공하는 방법에는 두 가지가 있다.
* 함수 원형을 소스코드 파일에 직접 입력한다.
* 함수 원형이 들어있는 cmath헤더 파일을 포함시킨다.
두 가지 방법 중 두 번째 방법이 실수를 저지를 위헙이 적다. C++ 라이브러리의 모든 함수들은 함수 원형이 하나 또는 그 이상의 헤더 파일에 들어 있다. 그러므로 라이브러리 사용 설명서나 온라인 도움말을 잘 찾아보고 적당한 헤더 파일을 포함시키면 된다.  
  
이제 혼동할 만한것은 함수 원형과 함수 정의인데, 함수 원형은 함수의 인터페이스만 알려주는 것이다. 즉, 그 함수에 전달하는 정보와 그 함수가 리턴하는 정보만을 서술하면 된다. 반면 함수 정의는 그 함수가 수행할 작업을 위한 실제 코드를 말한다. C++는 라이브러리 함수들에 대해서 이 두 가지 기능을 분리해두었다. 라이브러리 함수들의 컴파일된 코드는 라이브러리 파일에 들어 있고, 함수 원형들은 헤더 파일에 들어 있다.  
  
함수 원형은 그 함수가 처음 사용되는 곳 앞에 두어야 한다. 일반적인 관행은 main()함수 정의 앞에 함수 원형을 두는 것이다. Listing 2.4는 라이브러리 함수 sqrt()를 사용하는 방법을 설명하고 있다. 여기서는 cmath 헤더 파일을 포함시켜 함수 원형을 제공하고 있다.
```cpp
// Listing 2.4
// sqrt.cpp
#include <iostream>
#include <cmath>

int main()
{
    using namespace std;

    double area;
    cout << "마루 면적을 평방피트 단위로 입력하세요: ";
    cin >> area;
    double side;
    side = sqrt(area);
    cout << "사각형 마루라면 한 변이 " << side
        << "피트에 상당합니다." << endl;
    cout << "멋지네요!" << endl;
    return 0;
}
```
Listing 2.4의 실행 결과는 다음과 같다.
```
마루 면적을 평방피트 단위로 입력하시오: 1536
사각형 마루라면 한 변이 39.1918피트에 상당합니다.
멋지네요!
```
sqrt() 함수는 double형 데이터를 다루므로, 이 예제에서는 area와 side 모두 double형 변수로 만들었다. double형 변수를 선언하는 형식은 int형 변수를 선언하는 방식과 같다.
```cpp
type-name variable-name;
```
double형은 변수 area와 side에 1536.0, 39.1918과 같은 소수부가 있는 수들을 저장할 수 있게 한다. 정수 1536을 입력했지만, double형 변수에 저장될 때에는 .0의 소수부를 가진 실수값으로 저장된다. 
C++에서는 다음과 같이 변수를 선언할 때 값을 함께 대입할 수 있다.
```cpp
double side = sqrt(area);
```
이러한 과정을 초기화(initialization)라 부른다.  
cin은 입력 스트림에서 가져온 정보를 double형으로 변환하는 방법을 알고 있다. 또한 cout은 double형 정보를 출력 스트림에 삽입하는 방법을 알고 있다. 앞에서 이미 설명했듯이, 이것은 cin과 cout이 똑똑한 객체이기 때문이다.

* ## 변이 함수들
어떤 함수는 하나 이상의 정보를 요구한다. 그러한 함수는 여러 개의 매개변수를 콤마로 분리한다. 예를 들어 수학 함수인 pow()는 매개 변수를 2개 요구한다. 이 함수는 첫 번째 매개변수를 두 번째 매개변수의 횟수만큼 거듭제곱하여 그 결과값을 리턴한다. 이 함수의 원형은
```cpp
double pow(double, double);
```
이고, 다음과 같이 사용할 수 있다.
```cpp
result = pow(5.0, 8.0);
```
매개변수를 사용하지 않는 함수도 있다. 예를 들어, C라이브러리에는 매개변수는 사용하지 않지만, 임의의 정수를 리턴하는 rand()이라는 함수가 있다. 이 함수의 원형은
```cpp
int rand(void);
```
이다. void는 앞서 공부한것처럼 매개변수를 사용하지 않는다는 것을 명시적으로 밝히는 것이다. void를 생략하고 괄호 안을 그냥 비워두면, 매개변수를 사용하지 않는다는것을 묵시적으로 밝히는 것이다. 즉, 다음과 같이 코딩이 가능하다.
```cpp
result = rand();
```
다른 언어와는 달리 C++에서는 함수에 매개변수가 없더라도 함수 호출에 반드시 괄호를 사용해야 한다.  
  
값을 리턴하지 않는 함수도 있다. 예를 들어 미국 화폐를 달러-센트 형식으로 화면에 표시하는 함수를 하나 작성했다고 가정하자. 이 함수에 23.5라는 매개변수를 전달하면 화면에 $23.50이라고 표시한다. 이 함수는 값을 화면에 표시하는 것이기 때문에 호출 함수에게는 값을 리턴하지 않는다. 함수 원형을 이렇게 지정하려면 void를 사용하면 된다.
```cpp
void bucks(double);
```
C++에서는 함수가 값을 리턴하던 그렇지 않던 모두 함수(function)이라 칭한다.

* ## 사용자 정의 함수
표준 C라이브러리는 140개 이상의 미리 정의된 함수를 제공한다. 이들 중에 어느 것이 자신의 프로그래밍 요구에 적합핟면 그것을 사용하면 된다. 그러나 경우에 따라서는 사용자가 직접 함수를 작성해야 한다. 특히 클래스를 설계할 때에 그렇다. 자신이 직접 함수를 설계한다는 것은 가슴 설레는 일이다. 지금부터 사용자 정의 함수를 작성하는 방법에 대해 알아보자.  
  
우리는 사용자 정의 함수를 이미 몇번이나 사용해보았다. 그것은 바로 main() 함수이다. 이 외에 사용자 정의 함수를 선언하는법은 Listing 2.5를 통해 알아보자
```cpp
// Listing 2.5
// ourfunc.cpp
#include <iostream>
void simon(int);

int main()
{
    using namespace std;
    simon(3);
    cout << "정수를 하나 고르시오: ";
    int count;
    cin >> count;
    simon(count);
    cout << "끝!" << endl;
    return 0;
}

void simon(int n)
{
    using namespace std;
    cout << "Simon 왈, 발가락을 " << n << "번 두드려라." << endl;
}
```
